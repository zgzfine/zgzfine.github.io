---
title: LeetCode 37. 解数独
date: 2022-11-08 15:53:52
tags:
categories:
- LeetCode
- 回溯
---

编写一个程序，通过填充空格来解决数独问题。  

数独的解法需 遵循如下规则：  

数字1-9在每一行只能出现一次。  
数字1-9在每一列只能出现一次。  
数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。（请参考示例图）  
数独部分空格内已填入了数字，空白格用'.'表示。  

![](../images/leetcode37/250px-sudoku-by-l2g-20050714svg.png)

<!--more-->

示例 1：


输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]  
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]  
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：  
![](../images/leetcode37/250px-sudoku-by-l2g-20050714_solutionsvg.png)

提示：
* board.length == 9  
* board[i].length == 9  
* board[i][j] 是一位数字或者 '.'  
* 题目数据 保证 输入数独仅有一个解  


```
/**
 * 37. 解数独
 */
public class LeetCode37 {

    /**
     * 数独问题
     * 根据题意：
     * 1、数独一般都是9*9的数字棋盘等
     * 2、数独同一个数字在同一行，或者同一列，或者在相同的3*3宫格里不能重复，只能填写0~9的数字
     * 解法
     * 1、也只能用暴力破解，使用两层for循环确定当前的坐标，再使用一层0~9的循环回溯判断当前数字是否准确
     * 2、看到题目的返回类型是空，所以结果应该在原输入二维数组上修改
     */
    public void solveSudoku(char[][] board) {
        solveSudokuHelper(board);
    }

    private boolean solveSudokuHelper(char[][] board) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j< board[0].length; j++) {
                //当前坐标值
                char cru = board[i][j];
                if (cru != '.') {//当前坐标已经有数字，跳过
                    continue;
                }
                for (char k = '1'; k <= '9'; k++) {//1~9的数字当前坐标试错
                    if (isValue(i, j, k, board)) {
                        board[i][j] = k;
                        if (solveSudokuHelper(board)) {//找到结果，直接返回，这里是全文最最关键的点，要细致的品
                            return true;
                        }
                        board[i][j] = '.';//试错失败回溯
                    }
                }
                //目前上述1~9都试错没找到，那么就返回false,这个点不能漏，很关键
                return false;
            }
        }
        return true;
    }

    /**
     * 判断当前数字是否合法
     */
    private boolean isValue(int row, int col, char val, char[][] board) {
        //在同一行没有重复,这里必须要是从0到9开始遍历
        for (int j = 0; j < 9; j++) {
            if (board[row][j] == val) {
                return false;
            }
        }
        //在同一列没有重复，这里必须要是从0到9开始遍历 重点
        for (int i = 0; i < 9; i++) {
            if (board[i][col] == val) {
                return false;
            }
        }
        int startRow = row / 3 * 3;
        int stratCol = col / 3 * 3;
        for (int i = startRow; i < startRow + 3; i++) {
            for (int j = stratCol; j < stratCol + 3; j++) {
                if (board[i][j] == val) {
                    return false;
                }
            }
        }
        return true;
    }


}

```