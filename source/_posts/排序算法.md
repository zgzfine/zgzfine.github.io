---
title: 排序算法
date: 2022-06-18 15:36:17
tags:
---


> 排序算法是每个开发都必须要熟练掌握，是研究算法题的开端

排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。

排序算法总览：
![总括](../images/0006/a.png)

<!--more-->

# 关于时间复杂度

平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。  
线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；  
O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序  
线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。

# 关于稳定性

稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。  
不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。

名词解释：

* n：数据规模
* k："桶"的个数
* In-place：占用常数内存，不占用额外内存
* Out-place：占用额外内存
* 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同

---

# 1、冒泡排序

## 1.1 算法步骤

比较相邻的元素。如果第一个比第二个大，就交换他们两个。  
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。  
针对所有的元素重复以上的步骤，除了最后一个。  
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

## 1.2 动图演示

![冒泡](../images/0006/b.gif)

## 2.3 什么时候最快

当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。

## 2.4 什么时候最慢

当输入的数据是反序时

## 2.5 实现

~~~
public class BubbleSort {

    public int[] sort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。
            // 这里是冒泡排序的优化项
            boolean flag = true;
            for (int j = 0; j < arr.length - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                    flag = false;
                }
            }
            if (flag) {//数组已经有序，不需要继续进行了
                break;
            }
        }
        return arr;
    }
}
~~~

---

# 2、选择排序

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

## 2.1 算法步骤

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。  
再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。  
重复第二步，直到所有元素均排序完毕。

## 2.2 动图演示

![选择](../images/0006/c.gif)

## 2.3 实现

~~~
public class SelectionSort {

    public int[] sort(int[] arr) {
        // 总共要经过 N-1 轮比较
        for (int i = 0; i < arr.length - 1; i++) {
            int min = i;

            // 每轮需要比较的次数 N-i
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min]) {
                    // 记录目前能找到的最小值元素的下标
                    min = j;
                }
            }

            // 将找到的最小值和i位置所在的值进行交换
            if (i != min) {
                int tmp = arr[i];
                arr[i] = arr[min];
                arr[min] = tmp;
            }
        }
        return arr;
    }
}
~~~

---

# 3、 插入排序

插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。  
插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

## 3.1 算法步骤

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。  
从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

## 3.2 动图演示

![插入](../images/0006/d.gif)

## 3.3 实现

~~~
public class InsertSort {
    //插入排序
    public int[] sort(int[] arr) {
        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
        for (int i = 1; i < arr.length; i++) {
            // 从已经排序的序列最右边的开始比较，找到比其小的数
            int j = i;
            while (j > 0) {
                if (arr[j] >= arr[j - 1]) {
                    break;
                }
                int tmp = arr[j];
                arr[j] = arr[j - 1];
                arr[j - 1] = tmp;
                j--;
            }
        }
        return arr;
    }
}
~~~

# 4、希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。
希尔排序是基于插入排序的以下两点性质而提出改进方法的：

* 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

## 4.1 算法步骤

选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；  
按增量序列个数 k，对序列进行 k 趟排序；  
每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

## 4.2 动图演示

![希尔](../images/0006/e.gif)

## 4.3 实现

~~~
public static void shellSort(int[] arr) {
    int length = arr.length;
    int temp;
    for (int step = length / 2; step >= 1; step /= 2) {
        for (int i = step; i < length; i++) {
            temp = arr[i];
            int j = i - step;
            while (j >= 0 && arr[j] > temp) {
                arr[j + step] = arr[j];
                j -= step;
            }
            arr[j + step] = temp;
        }
    }
}
~~~

# 5、归并排序

归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。  
作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：

* 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；
* 自下而上的迭代；

在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：

> However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.
> 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。


说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。
和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。

## 5.1 算法步骤

* 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
* 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
* 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
* 重复步骤 3 直到某一指针达到序列尾；
* 将另一序列剩下的所有元素直接复制到合并序列尾。

## 5.2 动图演示

![归并](../images/0006/f.gif)

## 5.3 实现

~~~
public class MergeSort {

    public void sortHelper(int[] arr) {
        sort(arr, 0, arr.length - 1);
    }

    private static void sort(int[] arr, int left, int right) {
        if (left == right) {//左右相等，那么只剩下一个元素退出
            return;
        }
        int middle = left + (right - left) / 2;//取中位数的左边
        sort(arr, left, middle);//左手边再排序
        sort(arr, middle + 1, right);//右手边再排序
        merge(arr, left, middle + 1, right);//已经排序的结果合并
    }

    private static void merge(int[] arr, int left, int mid, int right) {
        int[] temp = new int[right - left + 1];//为什么要加1，假如 right = left,至少需要一个空间放元素
        int i = left;
        int j = mid;
        int n = 0;
        while (i < mid && j < right + 1) {//边界需要确定好，因为这边都是闭区间
            //那边小取那边
            if (arr[i] <= arr[j]) {
                temp[n] = arr[i];
                i++;
                n++;
            } else {
                temp[n] = arr[j];
                j++;
                n++;
            }
        }
        //将剩下的集合直接拷贝过去
        while (i < mid) {
            temp[n] = arr[i];
            i++;
            n++;
        }
        while (j < right + 1) {
            temp[n] = arr[j];
            j++;
            n++;
        }
        //将多余集合拷贝回去原数组
        i = left;//找准开始下标
        for (int value : temp) {
            arr[i] = value;
            i++;
        }
    }
}
~~~

# 6、快速排序

快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n^2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn)
算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。

快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为
O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：

> 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

## 6.1 算法步骤
* 从数列中挑出一个元素，称为 "基准"（pivot）;   
* 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；  
* 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

## 6.2 动图演示
![动图](../images/0006/g.gif)

## 6.3 实现
~~~
public class QuickSort {

    public void sort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }

    private static void quickSort(int[] arr, int left, int right) {
        if (left < right) {//只有在一个区间里，才有排序的意义
            int midIndex = partition(arr, left, right);
            //左右区间都是闭区间，所以不应该包括midIndex
            quickSort(arr, left, midIndex - 1);
            quickSort(arr, midIndex + 1, right);
        }
    }

    /**
     * 在 [left,right]区间随意找一个元素，确立这个元素在这个区间内的位置，并返回下标
     * 快速排序之所以快，就是因为在这个确立下标的过程中，做了一次排序定位
     */
    private static int partition(int[] arr, int left, int right) {
        //获取区间里任意的一个基准值，为了简化代码，所以使用第一个值
        int base = arr[left];
        int i = left;
        int j = right;
        //使用左右指针，使i、j逐渐相遇
        while (i != j) {//假如i、j没有相遇
            while (i != j && arr[j] >= base) {//如果当前j的值大于等于base那么就j缩小
                j--;
            }
            while (i != j && arr[i] <= base) {//如果当前i的值小于于等于base那么就i增小
                i++;
            }
            if (i != j) {
                swap(arr, i, j);
            }
        }
        //当前i、j已经相遇，那么就交互i以及base的数值
        arr[left] = arr[i];
        arr[i] = base;
        //此时i的值就是base在数组确立不动的下标
        return i;
    }

    //参数交换方法
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

}
~~~


# 7、堆排序

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：

* 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
* 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；
堆排序的平均时间复杂度为 Ο(nlogn)。

## 7.1 算法步骤
* 创建一个堆 H[0……n-1]；

* 把堆首（最大值）和堆尾互换；

* 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；

* 重复步骤 2，直到堆的尺寸为 1。

## 7.2 动图演示
![](../images/0006/heapSort.gif)

## 7.3 实现
```
/**
 * 堆排序
 */
public class HeapSort {

    /**
     * 1、第一步将数组转成一个大顶堆
     * 2、交换数组首尾元素
     * 3、调整除了尾元素外的元素成为一个新的大顶堆
     * 4、重复2、3步骤
     */
    public static void heapSort(int[] arr) {
        //1、第一步将数组转成一个大顶堆（这一步有点像冒泡排序 ）
        for (int i = arr.length / 2 - 1; i >= 0; i--) {//注意这里需要等于0，头结点也需要一次调整
            adjustHeap(arr, i, arr.length);
        }
        //4、加入for循环继续遍历
        for (int n = arr.length - 1; n > 0; n--) {
            //2、首尾交换
            int temp = arr[0];
            arr[0] = arr[n];
            arr[n] = temp;
            //3、此时的数组是一个除了首节点之外的大顶堆，所以只需要调整首节点
            adjustHeap(arr, 0, n);//数组最后一个元素排除掉
        }
    }

    /**
     * 构建以index为头结点的大顶堆
     * 原理就是比较左右孩子节点，那个大就交换，并重新构建
     *
     * @param arr 原数组
     * @param h   当前节点,当前头结点
     * @param n   原数组长度(注意是长度，所以是右开间)
     */
    private static void adjustHeap(int[] arr, int h, int n) {
        //index 的左节点=index*2+1，右节点=左节点+1
        int temp = arr[h];
        for (int j = h * 2 + 1; j < n; j = j * 2 + 1) {
            if (j + 1 < n && arr[j] < arr[j + 1]) {//如果左孩子小于右孩子，那么就交换头、右孩子
                j = j + 1;//右孩子节点赋给当前节点
            }
            if (arr[j] > temp) {
                arr[h] = arr[j];
                h = j;//!!!index 指向j，继续扮演下一轮节点比较
            } else {
                break;//头节点大于左右孩子节点，那么就停止for循环
            }
        }
        //最后必须要将temp赋值给arr[h],假如程序都没有进入for循环，这里的交换也不会有问题
        arr[h] = temp;
    }
}

```