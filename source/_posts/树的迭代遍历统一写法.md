---
title: 树的迭代遍历统一写法
date: 2022-10-17 17:19:01
tags:
categories:
- LeetCode
- 二叉树
---


> 刚学完树的迭代遍历，但是不一样的写法，会导致人大佬迷糊记不清，所以在此纪录一下统一的写法
<!--more-->

> 里面的方法使用到的是空标记法，单判断到空字节，则证明需要处理空节点了

```
 /**
 * 前序遍历
 * 中、左、右
 */
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    //栈不为空
    while (!stack.isEmpty()) {
        TreeNode node = stack.peek();
        if (node != null) {
            stack.pop();
            stack.push(node.rigth);//右
            stack.push(node.left);//左
            stack.push(node);     //中
            stack.push(null);
        } else {
            stack.pop();//弹出空元素
            node = stack.peek();
            if (node != null) {
                result.add(node.val);
                stack.pop();
            }
        }
    }
    return result;
}

/**
 * 后续遍历
 * 左、右、中
 */
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    //栈不为空
    while (!stack.isEmpty()) {
        TreeNode node = stack.peek();
        if (node != null) {
            stack.pop();
            stack.push(node);     //中
            stack.push(null);
            stack.push(node.rigth);//右
            stack.push(node.left);//左
        } else {
            stack.pop();//弹出空元素
            node = stack.peek();
            if (node != null) {
                result.add(node.val);
                stack.pop();
            }
        }
    }
    return result;
}



/**
 * 中序遍历
 * 左、中、右
 */
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    //栈不为空
    while (!stack.isEmpty()) {
        TreeNode node = stack.peek();
        if (node != null) {
            stack.pop();
            stack.push(node.rigth);//右
            stack.push(node);     //中
            stack.push(null);
            stack.push(node.left);//左
        } else {
            stack.pop();//弹出空元素
            node = stack.peek();
            if (node != null) {
                result.add(node.val);
                stack.pop();
            }
        }
    }
    return result;
}

```
