<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>有点意思的算法题</title>
    <url>/2022/03/09/0001/</url>
    <content><![CDATA[<h1 id="说点题外话"><a href="#说点题外话" class="headerlink" title="说点题外话~"></a>说点题外话~</h1><p>偶然一天，有个童鞋问了我这么一道题?</p>
<blockquote>
<p>给你一棵二叉树，请你返回层数最深的叶子节点的和</p>
</blockquote>
<span id="more"></span>

<p>刚开始看到这题的时候，其实没啥思路，虽然搬砖多年，但是对于算法方面的积累，估计就除了大学时候的算法结构课外，其他时间甚少接触。但是一向求(xi)知(huan)心(zhuang)切(bi)的我来说，立马就打开笔记本，刷刷刷搞起来</p>
<h1 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h1><h2 id="建立好基本"><a href="#建立好基本" class="headerlink" title="建立好基本"></a>建立好基本</h2><p>既然涉及树，那么不妨先建颗 <strong>树</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    //节点的值</span><br><span class="line">    public Integer val;</span><br><span class="line">    //左节点</span><br><span class="line">    public TreeNode left;</span><br><span class="line">    //右节点</span><br><span class="line">    public TreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树是由多个节点构成的，节点的属性相当简单，除了有本节点的值外，还有左节点，右节点（确实有点像树杈）。如上图一目了然，现在结构有了，当然想要初始化一颗树 <a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将数组转化为树</span><br><span class="line">//二叉树最为有意思的地方是，每个节点最多有两个分支</span><br><span class="line">//而且左节点的index必须要是当前index*2+1，右节点index = 当前index*2+2</span><br><span class="line">public static TreeNode arrayToTreeNode(Integer[] arrays) &#123;</span><br><span class="line">    if (arrays == null || arrays.length == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;TreeNode&gt; nodeList = new ArrayList&lt;&gt;();</span><br><span class="line">    for (Integer array : arrays) &#123;</span><br><span class="line">        nodeList.add(new TreeNode(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nodeList.size() / 2; i++) &#123;</span><br><span class="line">        if (i * 2 + 1 &lt; nodeList.size()) &#123;</span><br><span class="line">            nodeList.get(i).left = nodeList.get(i * 2 + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (i * 2 + 2 &lt; nodeList.size()) &#123;</span><br><span class="line">            nodeList.get(i).right = nodeList.get(i * 2 + 2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nodeList.get(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树的初始化已经完成，但是我又想要输出每个节点的值，看下是否有异常，于是脑海里想到 <em><strong>前序遍历</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 前序遍历</span><br><span class="line">*/</span><br><span class="line">public static void preLoad(TreeNode root) &#123;</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        System.out.print(&quot;,&quot;);</span><br><span class="line">        preLoad(root.left);</span><br><span class="line">        preLoad(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有前序遍历、当然少不了中序遍历、后序遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 中序遍历</span><br><span class="line">*/</span><br><span class="line">public static void midLoad(TreeNode root) &#123;</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        preLoad(root.left);</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        System.out.print(&quot;,&quot;);</span><br><span class="line">        preLoad(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 后序遍历</span><br><span class="line">*/</span><br><span class="line">public static void postLoad(TreeNode root) &#123;</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        preLoad(root.left);</span><br><span class="line">        preLoad(root.right);</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        System.out.print(&quot;,&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上说所说其实都是深度遍历 <strong>dfs</strong> 其实还有广度遍历 <strong>bfs</strong> 更多知识请参考 <a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">树的遍历</a></p>
<h2 id="正解部分"><a href="#正解部分" class="headerlink" title="正解部分"></a>正解部分</h2><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>最先想到的是深度排序，设定公共变量最大层数highmax,遍历叶子节点，如果当前叶子节点的层数等于highmax，则作sum运算，如果当前叶子节点层数大于highmax 则将值赋给sum，并重置目前最大层数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int higtMax = -1;</span><br><span class="line">int sum = 0;</span><br><span class="line"></span><br><span class="line">public int dfsMain(TreeNode root) &#123;</span><br><span class="line">    higtMax = -1;</span><br><span class="line">    sum = 0;</span><br><span class="line">    dfs(root, 0);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//写法上有点类似前序遍历</span><br><span class="line">public void dfs(TreeNode root, int high) &#123;</span><br><span class="line">    if (root != null &amp;&amp; root.val != null) &#123;</span><br><span class="line">        if (high == higtMax) &#123;</span><br><span class="line">            sum += root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        if (high &gt; higtMax) &#123;</span><br><span class="line">            higtMax = high;</span><br><span class="line">            sum = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, high + 1);</span><br><span class="line">        dfs(root.right, high + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考下，为什么要先判断等于再判断大于？</p>
</blockquote>
<h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p>这里其实就是广度遍历,使用队列最先想到 <em><strong>FIFO</strong></em>，从左到右遍历树，一层一层遍历下去，每一层遍历完之后判断队列是否空，如果空，则达到最深层，直接返回该层叶子点数相加之和即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 使用队列解答这题</span><br><span class="line">*/</span><br><span class="line">public static int queue(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; treeNodes = new LinkedList&lt;&gt;();</span><br><span class="line">    treeNodes.add(root);</span><br><span class="line">    int allSum = 0;</span><br><span class="line">    while (!treeNodes.isEmpty()) &#123;</span><br><span class="line">        int size = treeNodes.size();</span><br><span class="line">        int sum = 0;</span><br><span class="line">        //这个for主要是统计该层的节点值</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode poll = treeNodes.poll();</span><br><span class="line">            if (poll == null || poll.val == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += poll.val;</span><br><span class="line">            if (poll.left != null) treeNodes.add(poll.left);</span><br><span class="line">            if (poll.right != null) treeNodes.add(poll.right);</span><br><span class="line">        &#125;</span><br><span class="line">        allSum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    //队列为空，即可返回</span><br><span class="line">    return allSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>看起来简简单单的一道算法题，却花了我不少时间，又敲代码又调试啥的，其实最主要的原因还是平时积累少，思考少。不过，不管怎么样都好，作为自己的第一篇blog，算是在机缘巧合之中，又冥冥中带有一滴滴的缘分吧。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Github搭建个人博客</title>
    <url>/2022/04/10/0002/</url>
    <content><![CDATA[<p>既然都用github搭建博客，怎么也得要记录下采坑过程~</p>
<p>所以 ,,, GO~</p>
<span id="more"></span>

<h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。</p>
<ul>
<li>Node.js：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li>
<li>Git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li>
</ul>
<p>下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。</p>
<p>安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git –version 并回车，如下图出现程序版本号即可。</p>
<blockquote>
<p><img src="/../images/0002/a.png" alt="版本号"></p>
</blockquote>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>接下来就需要安装 Hexo 了，这是一个博客框架，Hexo 官方还提供了一个命令行工具，用于快速创建项目、页面、编译、部署 Hexo 博客，所以在这之前我们需要先安装 Hexo 的命令行工具。</p>
<p>命令如下：</p>
<blockquote>
<p>npm install -g hexo-cli</p>
</blockquote>
<p>安装完毕之后，确保环境变量配置好，能正常使用 hexo -v 命令。</p>
<blockquote>
<p><img src="/../images/0002/b.png" alt="版本号"></p>
</blockquote>
<h1 id="二、初始化项目"><a href="#二、初始化项目" class="headerlink" title="二、初始化项目"></a>二、初始化项目</h1><p>接下来我们使用 Hexo 的命令行创建一个项目，并将其在本地跑起来，整体跑通看看。</p>
<p>首先使用如下命令创建项目：</p>
<blockquote>
<p>hexo init {name}</p>
</blockquote>
<p>这里的 name 就是项目名，我这里要创建 NightTeam 的博客，我就把项目取名为 nightteam 了，用了纯小写，命令如下：</p>
<blockquote>
<p>hexo init blog</p>
</blockquote>
<p>这样 blog 文件夹下就会出现 Hexo 的初始化文件，包括 themes、scaffolds、source 等文件夹，这些内容暂且先不用管是做什么的，我们先知道有什么，然后一步步走下去看看都发生了什么变化。</p>
<p>接下来我们首先进入新生成的文件夹里面，然后调用 Hexo 的 generate 命令，将 Hexo 编译生成 HTML 代码，命令如下：</p>
<blockquote>
<p>hexo generate</p>
</blockquote>
<p>可以看到输出结果里面包含了 js、css、font 等内容，并发现他们都处在了项目根目录下的 public 文件夹下面了。</p>
<p>然后我们利用 Hexo 提供的 serve 命令把博客在本地运行起来，命令如下：</p>
<blockquote>
<p>hexo serve</p>
</blockquote>
<p>运行之后命令行输出如下：</p>
<blockquote>
<p>INFO  Start processing<br>INFO  Hexois running at <a href="http://localhost:4000/">http://localhost:4000</a> . Press Ctrl+C to stop</p>
</blockquote>
<p>它告诉我们在本地 4000 端口上就可以查看博客站点了</p>
<h2 id="三、-创建-Github-Pages-仓库"><a href="#三、-创建-Github-Pages-仓库" class="headerlink" title="三、 创建 Github Pages 仓库"></a>三、 创建 Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p>
<blockquote>
<p>Repository name 中输入 用户名.github.io<br>勾选 “Initialize this repository with a README”<br>Description 选填<br>填好后点击 Create repository 创建。</p>
</blockquote>
<p>创建后默认自动启用 HTTPS，博客地址为：https:&#x2F;&#x2F;用户名.github.io</p>
<h2 id="四、部署-Hexo-到-GitHub-Pages"><a href="#四、部署-Hexo-到-GitHub-Pages" class="headerlink" title="四、部署 Hexo 到 GitHub Pages"></a>四、部署 Hexo 到 GitHub Pages</h2><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p>
<p>首先安装 hexo-deployer-git：</p>
<blockquote>
<p>npm install hexo-deployer-git –save</p>
</blockquote>
<p>然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：</p>
<blockquote>
<p>deploy:<br>  type: git<br>  repository: <a href="mailto:&#103;&#x69;&#x74;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;">&#103;&#x69;&#x74;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;</a>:用户名&#x2F;用户名.github.io.git<br>  branch: master</p>
</blockquote>
<p>完成后运行 hexo d 将网站上传部署到 GitHub Pages。</p>
<p>完成！这时访问我们的 GitHub 域名 https:&#x2F;&#x2F;用户名.github.io 就可以看到 Hexo 网站了。</p>
<h1 id="五、初次尝试"><a href="#五、初次尝试" class="headerlink" title="五、初次尝试"></a>五、初次尝试</h1><h2 id="5-1-发布文章"><a href="#5-1-发布文章" class="headerlink" title="5.1 发布文章"></a>5.1 发布文章</h2><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p>
<blockquote>
<p>hexo new “My New Post”</p>
</blockquote>
<p>然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p>
<p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。以后每次发布文章都是这两条命令。</p>
<blockquote>
<p>hexo g   # 生成页面<br>hexo d   # 部署发布</p>
</blockquote>
<hr>
<p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line">- Diary</span><br><span class="line">tags: # 标签</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>hexo博客的源文件上传github</title>
    <url>/2022/04/13/0003/</url>
    <content><![CDATA[<p>又想要随时随地撸blog，所有又有啥快速的办法呢？</p>
<span id="more"></span>

<h1 id="一、建立分支hexo"><a href="#一、建立分支hexo" class="headerlink" title="一、建立分支hexo"></a>一、建立分支hexo</h1><p>1、在本地D盘下（位置任意）右键Git bash here，执行以下指令，把zgzfine.github.io项目文件克隆到本地：</p>
<blockquote>
<p>git clone <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#99;&#111;&#109;">&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#99;&#111;&#109;</a>:zgzfine&#x2F;zgzfine.github.io.git</p>
</blockquote>
<p>2、然后D盘下就会有个zgzfine.github.io的文件夹，里面的文件就是repository上的。<br>3、进入zgzfine.github.io，删除文件夹里除了.git的其他所有文件<br>4、把你的blog文件夹内的所有文件全部复制到zgzfine.github.io&#x2F;下<br>5、里面应该有个叫.gitignore的文件，没有的话就自己创建一个，里面的内容如下：</p>
<p><img src="/../images/0003/b.png" alt="文件"></p>
<p>6、创建一个叫hexo（或者blog，名字随意）的分支，并切换到这个分支</p>
<blockquote>
<p>git checkout -b hexo</p>
</blockquote>
<p>7、添加所有文件到暂存区</p>
<blockquote>
<p>git add –all</p>
</blockquote>
<p>8、进行提交</p>
<blockquote>
<p> git commit -m “init”</p>
</blockquote>
<p>9、推送hexo分支的文件到github仓库</p>
<blockquote>
<p> git push –set-upstream origin hexo</p>
</blockquote>
<h1 id="二、初始化"><a href="#二、初始化" class="headerlink" title="二、初始化"></a>二、初始化</h1><p>1、同理在github上下载源文件</p>
<blockquote>
<p>git clone <a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;">&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;</a>:zgzfine&#x2F;zgzfine.github.io.git </p>
</blockquote>
<p>2、切换分支</p>
<blockquote>
<p>git checkout -b hexo origin&#x2F;hexo</p>
</blockquote>
<p>3、安装hexo</p>
<blockquote>
<p>npm install -g hexo-cli</p>
</blockquote>
<p>在这部有可能安装失败，可以使用以下命令</p>
<blockquote>
<p>npm install hexo –save</p>
</blockquote>
<p>4、发布推送</p>
<blockquote>
<p> hexo d</p>
</blockquote>
<p>到此，步骤已经结束，可以愉快的撸起来</p>
]]></content>
  </entry>
  <entry>
    <title>Github Support for password authentication was removed on August 13, 2021</title>
    <url>/2022/05/15/0004/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>昨天偶然想往Github上提交一个新项目，在常规的输入Username和Password之后，Github返回了这样一个错误：</p>
<blockquote>
<p>remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.<br>remote: Please see <a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/</a> for more information.</p>
</blockquote>
<span id="more"></span>

<p>大概意思就是，以前的密码认证从2021年8月13日开始就不能用了，必须使用个人访问令牌（personal access token），也就是把你的密码替换成token。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>官方解释：<a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/</a></p>
</blockquote>
<p>近年来，GitHub 客户受益于 GitHub.com 的多项安全增强功能，例如双重身份验证、登录警报、验证设备、防止使用泄露密码和WebAuthn 支持。这些功能使攻击者更难获取在多个网站上重复使用的密码并使用它来尝试访问您的 GitHub 帐户。尽管有这些改进，但由于历史原因，未启用双因素身份验证的客户仍然能够仅使用其 GitHub 用户名和密码继续对 Git 和 API 操作进行身份验证。</p>
<p>从 2021 年 8 月 13 日开始，我们在对 Git 操作进行身份验证时将不再接受帐户密码，并将要求使用基于令牌的身份验证，例如个人访问令牌（针对开发人员）或 OAuth 或 GitHub 应用程序安装令牌（针对集成商）适用于 GitHub.com 上所有经过身份验证的 Git 操作。您也可以在您喜欢的地方继续使用 SSH 密钥。</p>
<p>与基于密码的身份验证相比，令牌提供了许多安全优势：</p>
<ul>
<li>唯一 —— 令牌特定于 GitHub，可以按使用或按设备生成</li>
<li>可撤销 —— 令牌可以随时单独撤销，无需更新未受影响的凭据</li>
<li>有限 —— 令牌的范围可以很窄，只允许用例所需的访问权限</li>
<li>随机 —— 令牌不受字典类型或暴力尝试的影响，您需要记住或定期输入的更简单的密码可能是</li>
</ul>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>找到个人Settings页面：<br><img src="/../images/0004/a.png" alt="tag"></p>
<p>找到Developer settings（我截图的时候这个选项在最下面）<br><img src="/../images/0004/b.png" alt="tag"></p>
<p>选择个人访问令牌Personal access tokens，然后选中生成令牌Generate new token<br><img src="/../images/0004/c.png" alt="tag"></p>
<p>设置token的特性，比如：标题，有效期，token权限,并勾选所有<br><img src="/../images/0004/d.png" alt="tag"></p>
<p>生成令牌Generate token<br><img src="/../images/0004/e.png" alt="tag"></p>
<p>把token复制下来(token只能查看一次之后就不在展示)</p>
<p>之后提交代码的时候，在之前输入密码的地方输入这个token就可以了。</p>
<p>也可以 把token直接添加远程仓库链接中，这样就可以避免同一个仓库每次提交代码都要输入token了：</p>
<blockquote>
<p>git remote set-url origin <a href="https://your_token@github.com/USERNAME/REPO.git">https://your_token@github.com/USERNAME/REPO.git</a></p>
</blockquote>
<ul>
<li>your_token:换成你自己得到的token  </li>
<li>USERNAME:是你自己github的用户名  </li>
<li>REPO:是你的仓库名称</li>
</ul>
<h2 id="还有点新鲜事儿"><a href="#还有点新鲜事儿" class="headerlink" title="还有点新鲜事儿"></a>还有点新鲜事儿</h2><p>这事儿说新鲜也不新鲜了，就是新创建的repo里面，默认分支已经从master改名成main了。</p>
<p>因为在2020年6月份，受美国大规模的 “Black Lives Matter”运动影响，为了安抚愈演愈烈的民众情绪，GitHub 就宣布将替换掉 master 等术语，以避免联想奴隶制。</p>
<p>而对于为何选择“main”而不是其他替换词汇，Github 方面给出的解释为，main 是他们在平台上看到的最受欢迎的 master 替代品。并且 main 这个词汇很短，可以帮助用户形成良好的肌肉记忆；在很多种语言中翻译起来也都很容易。</p>
]]></content>
  </entry>
  <entry>
    <title>PSV游戏安装教程</title>
    <url>/2022/06/16/0005/</url>
    <content><![CDATA[<p>这里主要介绍的是vpk格式和文件夹形式的mai与NND格式游戏安装方法,推荐使用usb上传后使用文件夹格式安装更快。</p>
<span id="more"></span>

<p>游戏的安装方法一般会标注在文件名尾部，如 <strong>[NND]</strong> 表示NND格式，**[mai]** 表示mai格式</p>
<p>准备工作.小V必备的软件：</p>
<p>VitaShell（文件管理器，主要用于usb传输和vpk安装、文件管理等）</p>
<p>项目地址：<a href="https://github.com/TheOfficialFloW/VitaShell">https://github.com/TheOfficialFloW/VitaShell</a></p>
<p>下载地址: VitaShell.rar 解压密码: yang2000ling.cn</p>
<p>MaiDumpTool （mai游戏解密提取工具，另外还有安装文件夹格式游戏和补丁、dlc等功能）</p>
<p>项目地址：<a href="https://github.com/BeniYukiMai/MaiDumpTool/releases/">https://github.com/BeniYukiMai/MaiDumpTool/releases/</a></p>
<p>下载地址: MaiDumpTool_V233.2zEx.rar 解压密码: yang2000ling.cn</p>
<hr>
<p>方法一 vpk安装、打包方法：<br>其实vpk格式是一种zip的压缩包，所以可以使用压缩软件直接打开，安装方法也简单,上传到小V后直接用vitashell选择安装就可以了。 下面介绍下vpk游戏格式的文件结构，方便了解游戏是不是vpk格式的结构,是不是错误导致无法安装等问题。 具体就不在做详细说明了，有需要的可以自行百度。</p>
<p><img src="/../images/0005/1.jpg" alt="psv"></p>
<p>电脑上用压缩软件打开就如上图是这个种结构，就代表是正确的，简单的判断就是根目录下没有红框里面的文件，所以下载来的文件夹格式只要结构正确就可以把所有文件打包zip格式的压缩包，完成后把后缀.zip改成vpk就可以了。 文件没有显示后缀的又不知道哪里改的也请自行百度。</p>
<hr>
<p>方法二 mai格式安装方法：<br>mai安装需要注意的是文件一定要传到 ux0:&#x2F;mai 文件夹里，如果没有自行建立。 这个需要你安装了上面mai软件，游戏传到小V后打开mai选择文件夹安装在选游戏就可以安装完成，vitashell现在也支持文件夹格式的安装但是我几乎没用过（有兴趣的朋友可以试试看），所以还是推荐使用mai安装。 vpk格式的也可以转文件夹格式，是要把vpk的文件全部解压出来传到自定文件夹了用mai安装。但需要注意的是这个比vpk的结构多了一层文件夹。</p>
<p><img src="/../images/0005/psv2.jpg" alt="psv"></p>
<p>主要多了一个以游戏id为名的文件夹，里面才是之前说的vpk里的文件结构，所以转文件夹格式时要自行建立以游戏id的文件夹，把游戏解压到里面。 上传时要传游戏id名的文件夹到 ux0:&#x2F;mai 。</p>
<p>mai安装游戏路径说明（游戏id为每个游戏游戏标号 例如：PCSD00085）：</p>
<blockquote>
<p>游戏本体：ux0:&#x2F;mai&#x2F;游戏id</p>
</blockquote>
<blockquote>
<p>游戏补丁：ux0:&#x2F;mai&#x2F;游戏id_patch</p>
</blockquote>
<blockquote>
<p>DLC：ux0:&#x2F;mai&#x2F;游戏id_addc</p>
</blockquote>
<p>mai的游戏dlc需要更改游戏加载模式为5</p>
<hr>
<p>方法三 NoNpDrm（NND格式）游戏安装方法：<br>注意：NoNpDrm版本的游戏不能使用mai安装！</p>
<p>把游戏所有文件传到内存卡（ux0）下，具体请查看存放位置说明，然后用VitaShell在ux0上按三角选Refresh LiveArea更新图标（第一项），刷新完成桌面就会有游戏的气泡，或者使用工具箱刷新游戏气泡。</p>
<p>NoNpDrm游戏需要插件支持才能游戏，点击下载NoNpDrm v1.2插件，里面下载和安装方法。</p>
<p>ps：NoNpDrm插件安装和刷新游戏都可以工具箱操作。</p>
<p>NoNpDrm游戏区分很简单，因为是加密的所以在游戏里随便找个图片打开，如果图片无法正常显示就是NoNpDrm格式的游戏。</p>
<p>打开vita工具箱，选择常用插件大全，安装NoNpDrm插件，如果安装过该插件的可以跳过这个步骤。</p>
<p><img src="/../images/0005/3.jpg" alt="psv"></p>
<p><img src="/../images/0005/4.jpg" alt="psv"></p>
<p>用数据线把PSV连接到电脑上，接下来在vitashell或者vita工具箱主界面按start键启用USB连接。</p>
<p>把NoNpDrm游戏拷贝到PSV储存卡{或卡托TF卡}的相应目录下：</p>
<p>NoNpDrm游戏文件存放位置：</p>
<blockquote>
<p>游戏本体传输到ux0:&#x2F;app下，路径为ux0:&#x2F;app&#x2F;游戏编号</p>
</blockquote>
<blockquote>
<p>DLC传输到ux0:&#x2F;addcont下，路径为ux0:&#x2F;addcont&#x2F;游戏编号</p>
</blockquote>
<blockquote>
<p>补丁传输到ux0:&#x2F;patch下，路径为ux0:&#x2F;patch&#x2F;游戏编号</p>
</blockquote>
<p>如果下载的游戏文件包括（如app、addcont、patch其中一个或几个）这些文件夹的直接用数据线上传到ux0根目录就可以了。</p>
<p><img src="/../images/0005/5.jpg" alt="psv"></p>
<p><img src="/../images/0005/6.jpg" alt="psv"></p>
<p>上传完成后用vitashell或使用工具箱刷新出游戏气泡，必须是安装了NoNpDrm插件后才能刷出。</p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 1. 两数之和</title>
    <url>/2022/10/11/LeetCode1/</url>
    <content><![CDATA[<blockquote>
<p>给定一个整数数组 nums和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。  </p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br> 你可以按任意顺序返回答案。</p>
</blockquote>
<p>示例 1：<br>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。  </p>
<p>示例 2：<br>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]  </p>
<p>示例 3：<br>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 假如使用暴力算法，那么这个题的时间复杂度是 O(N^2),所以需要找到更加快的方法，比如有没有可能O(N)或者O(logN)?</span><br><span class="line"> * 首先想到 哈希表， 映射的方法，时间复杂度是O(N),空间复杂度O(N)</span><br><span class="line"> */</span><br><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        int a = target - nums[i];</span><br><span class="line">        if (map.containsKey(a)) &#123;</span><br><span class="line">            return new int[]&#123;map.get(a), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    return new int[2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>哈希表</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 添加分类及标签</title>
    <url>/2022/10/09/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>关于hexo里面的分类以及标签的定义，以及如何在个人博客中添加如下两个样式。</p>
<span id="more"></span>

<blockquote>
<p>生成的新文件夹都在source下也就是和放文章的文件夹一块,以下所有命令都是在博客文件目录下执行</p>
</blockquote>
<h1 id="1-创建“分类”选项"><a href="#1-创建“分类”选项" class="headerlink" title="1. 创建“分类”选项"></a>1. 创建“分类”选项</h1><p>生成“分类”页并添加tpye属性,进入博客目录。执行命令下方命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>categories文件夹下会有index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-04-22 14:47:40</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加type: “categories”到内容中，添加后是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2019-04-24 15:30:30</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>保存并关闭文件。</p>
<p>给文章添加“categories”属性</p>
<p>打开需要添加分类的文章，为其添加categories属性。下方的categories:Hexo表示这篇文章添加到到“Hexo”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p>
<h1 id="2-创建“标签”选项"><a href="#2-创建“标签”选项" class="headerlink" title="2. 创建“标签”选项"></a>2. 创建“标签”选项</h1><p>生成“标签”页并添加tpye属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags </span><br></pre></td></tr></table></figure>

<p>复制代码在tags文件夹下，找到index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2019-04-22 14:22:08</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2019-04-24 15:40:24</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>保存并关闭文件。<br>给文章添加“tags”属性,打开需要添加标签的文章，为其添加tags属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2019-04-24 15:40:24</span><br><span class="line">categories:</span><br><span class="line"></span><br><span class="line">- Hexo</span><br><span class="line">  tags:</span><br><span class="line">- 博客</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 101. 对称二叉树</title>
    <url>/2022/10/18/LeetCode101/</url>
    <content><![CDATA[<blockquote>
<p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
</blockquote>
<span id="more"></span>

<p>示例 1：<br><img src="/../images/leetcode101/symtree1.jpg"></p>
<p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true  </p>
<p>示例 2：<br><img src="/../images/leetcode101/symtree2.jpg"></p>
<p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false  </p>
<p>提示：</p>
<p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100  </p>
<blockquote>
<p>这道题经验是简单题，我的天，实际上，还是挺绕的代码量也不少，但是明白原理之后，还好理解  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 确立条件，既然是判断是否对称，因此需要两个比较的节点 ，定义 l，那么比较之后的结果是什么，当时就是返回值</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 这里不要管 l，r是那棵树，那个节点，方正就是需正确比较是否对称的节点树，不然很容易绕进去</span><br><span class="line"> */</span><br><span class="line">public static boolean order(TreeNode l, TreeNode r) &#123;</span><br><span class="line">    if (l == null &amp;&amp; r == null) &#123;//l、r都是空，对称</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else if (l != null &amp;&amp; r == null) &#123;//l,不空，r空，不对称</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else if (l == null &amp;&amp; r != null) &#123;//l,空，r不空，不对称</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else if (l.val != r.val) &#123;//l,r都不为空，但是值不等</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //值相等的情况下，比较左子树的左节点跟右子树的右节点</span><br><span class="line">    boolean order = order(l.left, r.right);</span><br><span class="line">    //比较左子树的右节点跟右子树的左节点</span><br><span class="line">    boolean order1 = order(l.right, r.left);</span><br><span class="line">    return order &amp;&amp; order1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 方法二、使用迭代法</span><br><span class="line"> * 使用队列实现，判断目前队列里面的size，把左子树，右子树入队，然后出队，对比一下即可</span><br><span class="line"> */</span><br><span class="line">public boolean isSymmetric2(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; qe = new LinkedList&lt;&gt;();</span><br><span class="line">    //由于判断左右子树是否对称，所以是左右子树入队</span><br><span class="line">    qe.offer(root.left);</span><br><span class="line">    qe.offer(root.right);</span><br><span class="line">    while (!qe.isEmpty()) &#123;</span><br><span class="line">        TreeNode l = qe.poll();</span><br><span class="line">        TreeNode r = qe.poll();</span><br><span class="line">        if (l == null &amp;&amp; r == null) &#123;//l、r都是空，对称</span><br><span class="line">            continue;//下一个循环</span><br><span class="line">        &#125; else if (l != null &amp;&amp; r == null) &#123;//l,不空，r空，不对称</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (l == null &amp;&amp; r != null) &#123;//l,空，r不空，不对称</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (l.val != r.val) &#123;//l,r都不为空，但是值不等</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        qe.offer(l.left);</span><br><span class="line">        qe.offer(r.right);</span><br><span class="line">        qe.offer(l.right);</span><br><span class="line">        qe.offer(r.left);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 05. 替换空格</title>
    <url>/2022/10/12/LeetCode05/</url>
    <content><![CDATA[<blockquote>
<p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
</blockquote>
<span id="more"></span>


<p>示例 1：</p>
<p>输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”  </p>
<p>限制：  </p>
<p>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 1、统计字符串有多少空格</span><br><span class="line"> * 2、没有空格直接返回</span><br><span class="line"> * 采用双指针，从右往左赋值</span><br><span class="line"> */</span><br><span class="line">public String replaceSpace(String s) &#123;</span><br><span class="line">    if (s == null || s.length() == 0) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    char[] chars = s.toCharArray();</span><br><span class="line">    StringBuilder str = new StringBuilder();</span><br><span class="line">    for (char c : chars) &#123;</span><br><span class="line">        if (c == &#x27; &#x27;) &#123;</span><br><span class="line">            //有一个空格，需要多增加两个空格</span><br><span class="line">            str.append(&quot;  &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果没有空格，返回</span><br><span class="line">    if (str.length() == 0) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    //左下标标记原字符串末尾</span><br><span class="line">    int left = s.length() - 1;</span><br><span class="line">    //扩容原数组，不使用新数组</span><br><span class="line">    s = s + str;</span><br><span class="line">    //右下标标记现数组的末尾</span><br><span class="line">    int right = s.length() - 1;</span><br><span class="line">    //开始往左移动，直到左左边数值为0</span><br><span class="line"></span><br><span class="line">    char[] charArray = s.toCharArray();</span><br><span class="line">    while (left &gt;= 0) &#123;</span><br><span class="line">        if (charArray[left] == &#x27; &#x27;) &#123;//等于空格</span><br><span class="line">            //当前值赋值</span><br><span class="line">            charArray[right] = &#x27;0&#x27;;</span><br><span class="line">            right--;</span><br><span class="line">            charArray[right] = &#x27;2&#x27;;</span><br><span class="line">            right--;</span><br><span class="line">            charArray[right] = &#x27;%&#x27;;//最后</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            charArray[right] = charArray[left];</span><br><span class="line">        &#125;</span><br><span class="line">        left--;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(charArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 104. 二叉树的最大深度</title>
    <url>/2022/10/21/LeetCode104/</url>
    <content><![CDATA[<blockquote>
<p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。  </p>
</blockquote>
<span id="more"></span>

<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<p> 3<br>&#x2F; <br>9  20<br>&#x2F;  <br>15   7<br>返回它的最大深度3 。</p>
<p>ps:在leetcode上，一个节点算深度1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一般二叉树，链表，数据结构相似，使用递归会比较容易得出结论</span><br><span class="line"> * 1、求左子树的最大深度</span><br><span class="line"> * 2、求右子树的最大深度</span><br><span class="line"> * 3、Math.max(左右子树) ，再加 1</span><br><span class="line"> */</span><br><span class="line">public int maxDepth(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int left = maxDepth(root.left);</span><br><span class="line">    int rigth = maxDepth(root.right);</span><br><span class="line">    return Math.max(left, rigth) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 106. 从中序与后序遍历序列构造二叉树</title>
    <url>/2022/10/22/LeetCode106/</url>
    <content><![CDATA[<p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<span id="more"></span>

<p>示例 1:<br><img src="/../images/leetcode106/tree.jpg"></p>
<p>输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]<br>输出：[3,9,20,null,null,15,7]</p>
<p>示例 2:<br>输入：inorder &#x3D; [-1], postorder &#x3D; [-1]<br>输出：[-1]</p>
<p>提示:</p>
<ul>
<li>1 &lt;&#x3D; inorder.length &lt;&#x3D; 3000</li>
<li>postorder.length &#x3D;&#x3D; inorder.length</li>
<li>-3000 &lt;&#x3D; inorder[i], postorder[i] &lt;&#x3D; 3000</li>
<li>inorder和postorder都由 不同 的值组成</li>
<li>postorder中每一个值都在inorder中</li>
<li>inorder保证是树的中序遍历</li>
<li>postorder保证是树的后序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 递归法</span><br><span class="line"> * 1、确立当前节点</span><br><span class="line"> * 2、确立当前节点的左节点</span><br><span class="line"> * 3、确立当前节点的右节点</span><br><span class="line"> * 4、返回当前节点</span><br><span class="line"> *</span><br><span class="line"> * @param inorder   中序数组</span><br><span class="line"> * @param postorder 后序数组</span><br><span class="line"> * @return 结果树</span><br><span class="line"> */</span><br><span class="line">public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">    if (postorder == null || postorder.length == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode curNode = new TreeNode(postorder[postorder.length - 1]);</span><br><span class="line">    //返回条件，当前是叶子节点</span><br><span class="line">    if (postorder.length == 1) &#123;</span><br><span class="line">        return curNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据cur，切割inorder 找出切割点</span><br><span class="line">    int leftLen = 0;</span><br><span class="line">    while (inorder[leftLen] != curNode.val) &#123;</span><br><span class="line">        leftLen++;</span><br><span class="line">    &#125;</span><br><span class="line">    //中序数组的左子集合，请注意上面的写法多加加了一次 Arrays.copyOfRange 这个方法是左闭右开</span><br><span class="line">    int[] inleft = Arrays.copyOfRange(inorder, 0, leftLen);</span><br><span class="line">    //中序数组的右子集合</span><br><span class="line">    int[] inright = Arrays.copyOfRange(inorder, leftLen + 1, inorder.length);</span><br><span class="line"></span><br><span class="line">    //后序数组的左子集，注意这里必须要使用 中序数组的左子集长度</span><br><span class="line">    int[] postleft = Arrays.copyOfRange(postorder, 0, inleft.length);</span><br><span class="line">    int[] postright = Arrays.copyOfRange(postorder, inleft.length, postorder.length - 1);</span><br><span class="line"></span><br><span class="line">    curNode.left = buildTree(inleft, postleft);// 中序数组的左子集合，后序数组的左子集</span><br><span class="line">    curNode.right = buildTree(inright, postright);// 中序数组的右子集合，后续数组的右子集</span><br><span class="line">    return curNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树的构建</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 110. 平衡二叉树</title>
    <url>/2022/10/21/LeetCode110/</url>
    <content><![CDATA[<p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<span id="more"></span>

<p>示例 1：<br><img src="/../images/leetcode110/balance_1.jpg"></p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：true</p>
<p>示例 2：<br><img src="/../images/leetcode110/balance_2.jpg"></p>
<p>输入：root &#x3D; [1,2,2,3,3,null,null,4,4]<br>输出：false<br>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：true</p>
<p>提示：</p>
<p>树中的节点数在范围 [0, 5000] 内<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 104</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 这道题也可以稍微参考下104</span><br><span class="line"> * 一开始接触这道题的时候，觉得，这怎么可能是到easy 题，至少用迭代法，会复杂很多，所以只能先掌握递归</span><br><span class="line"> * 1、还是从宏观上考量，分成三个节点，root、left、right，左子树是否平衡，右子树是否平衡，当前树是否评审</span><br><span class="line"> * 2、假如我们使用后序遍历，那么上面的问题可以简单的归纳为 当前叶子节点的上级节点是否平衡</span><br><span class="line"> * 3、需要一个获取高度的函数</span><br><span class="line"> * 4、通过高度差的计算判断是否平衡二叉树</span><br><span class="line"> */</span><br><span class="line">public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">    return depth(root) != -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param node 当前节点</span><br><span class="line"> * @return 当前节点最大高度</span><br><span class="line"> * 假如不是平衡树，返回-1</span><br><span class="line"> */</span><br><span class="line">public int depth(TreeNode node) &#123;</span><br><span class="line">    if (node == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //后序遍历</span><br><span class="line">    int left = depth(node.left);</span><br><span class="line">    if (left == -1) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    int right = depth(node.right);</span><br><span class="line">    if (right == -1) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //到这步，左右子树都是平衡二叉树</span><br><span class="line">    //如果高度差大于1，就不是平衡树，返回-1，否则返回最大的深度+1</span><br><span class="line">    return Math.abs(left - right) &gt; 1 ? -1 : Math.max(left, right) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 111. 二叉树的最小深度</title>
    <url>/2022/10/18/LeetCode111/</url>
    <content><![CDATA[<blockquote>
<p>给定一个二叉树，找出其最小深度。</p>
</blockquote>
<span id="more"></span>

<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>示例 1：<br>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：2  </p>
<p>示例 2：<br>输入：root &#x3D; [2,null,3,null,4,null,5,null,6]<br>输出：5</p>
<p>提示：<br>树中节点数的范围在 [0, 105] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 相比于求二叉树最大深度，求最小深度也能使用层序遍历，当层序遍历遇到左右孩子都是null的时候，就是找到最小深度的</span><br><span class="line"> */</span><br><span class="line">public int minDepth(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; qe = new LinkedList&lt;&gt;();</span><br><span class="line">    qe.offer(root);</span><br><span class="line">    int depth = 0;</span><br><span class="line">    while (!qe.isEmpty()) &#123;</span><br><span class="line">        depth++;</span><br><span class="line">        int size = qe.size();</span><br><span class="line">        while (size-- &gt; 0) &#123;</span><br><span class="line">            TreeNode node = qe.poll();</span><br><span class="line">            if (node.left == null &amp;&amp; node.right == null) &#123;</span><br><span class="line">                return depth;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                qe.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                qe.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 1302. 层数最深叶子节点的和</title>
    <url>/2022/10/18/LeetCode1302/</url>
    <content><![CDATA[<blockquote>
<p>给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和 。<br><img src="/../images/leetcode1302/1483_ex1.png"></p>
</blockquote>
<span id="more"></span>

<p>示例 1：<br>输入：root &#x3D; [1,2,3,4,5,null,6,7,null,null,null,null,8]<br>输出：15  </p>
<p>示例 2：<br>输入：root &#x3D; [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]<br>输出：19  </p>
<p>提示：</p>
<p>树中节点数目在范围 [1, 104]之间。<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 100  </p>
<p>Ps:原来本blog第一篇日志的题目是出自这里，哈哈哈，那么就用不一样的解法吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int deepestLeavesSum(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; qe = new LinkedList&lt;&gt;();</span><br><span class="line">    qe.offer(root);</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while (!qe.isEmpty()) &#123;</span><br><span class="line">        sum = 0;//由于需要统计最深节点的和，所以每次都需要归零</span><br><span class="line">        int size = qe.size();</span><br><span class="line">        while (size-- &gt; 0) &#123;</span><br><span class="line">            TreeNode node = qe.poll();</span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">                sum = sum + node.val;</span><br><span class="line">                if (node.left != null) &#123;</span><br><span class="line">                    qe.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node.right != null) &#123;</span><br><span class="line">                    qe.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 142. 环形链表 II</title>
    <url>/2022/10/04/LeetCode142/</url>
    <content><![CDATA[<blockquote>
<p>给定一个链表的头节点 head，返回链表开始入环的第一个节点。如果链表无环，则返回null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>不允许修改 链表。</p>
</blockquote>
<span id="more"></span> 

<blockquote>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。  </p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用快慢指针能判断是否有环(相遇就是有环，但是相遇的不是第一个相遇的节点)</span><br><span class="line"> * 假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z</span><br><span class="line"> * 那么相遇时： slow指针走过的节点数为: x + y， fast指针走过的节点数：x + y + n (y + z)，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * (x + y) * 2 = x + y + n (y + z)</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 两边消掉一个（x+y）: x + y = n (y + z)</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 当 n为1的时候，公式就化解为 x = z</span><br><span class="line"> */</span><br><span class="line">public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">    ListNode fastNode = head;</span><br><span class="line">    ListNode showNode = head;</span><br><span class="line">    while (fastNode != null &amp;&amp; fastNode.next != null) &#123;</span><br><span class="line">        fastNode = fastNode.next.next;</span><br><span class="line">        showNode = showNode.next;</span><br><span class="line">        if (fastNode == showNode) &#123;</span><br><span class="line">            ListNode a = head;</span><br><span class="line">            ListNode b = fastNode;</span><br><span class="line">            while (a != b) &#123;</span><br><span class="line">                a = a.next;</span><br><span class="line">                b = b.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 15. 三数之和</title>
    <url>/2022/10/12/LeetCode15/</url>
    <content><![CDATA[<blockquote>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。</p>
</blockquote>
<span id="more"></span>


<blockquote>
<p>你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。  </p>
</blockquote>
<p>示例 1：<br>输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。<br>nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。<br>nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。  </p>
<p>示例 2：<br>输入：nums &#x3D; [0,1,1]<br>输出：[]<br>解释：唯一可能的三元组和不为 0 。  </p>
<p>示例 3：<br>输入：nums &#x3D; [0,0,0]<br>输出：[[0,0,0]]<br>解释：唯一可能的三元组和为 0 。  </p>
<p>提示：  </p>
<p>3 &lt;&#x3D; nums.length &lt;&#x3D; 3000<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 题目里面的难点</span><br><span class="line"> * 1、时间复杂度</span><br><span class="line"> * 2、不可以包含重复的三元组</span><br><span class="line"> * 假如使用暴力破解那么，这里会有 O(N^3)的时间复杂度</span><br><span class="line"> * 所以考虑减低复杂度，使用 排序+双指针的方法</span><br><span class="line"> * 由于排序的时间复杂度是 O(N*logN),双指针O(N^2) 所有最终时间复杂度O(N*logN)+O(N^2)=O(N^2)</span><br><span class="line"> */</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    //直接使用函数的排序算法，一般时间复杂度都是 O(N^2)或者O(NlogN)</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    //根据</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 2; i++) &#123;</span><br><span class="line">        //经过排序后的数组,首数字不能大于0，不然后续就不需要遍历,这块算是折枝的手段</span><br><span class="line">        if (nums[i] &gt; 0) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 特别关键的步骤</span><br><span class="line">         * i 至少等于1</span><br><span class="line">         * 跟前一个数值对比，如果相等，那么就意味这可以过滤调重复的组合</span><br><span class="line">         * 反过来如果是跟后面的一个数值对比，那么就可能缺失以下的这种情况 [-1,-1,2]，这里需要细致思考</span><br><span class="line">         * 如果不用这种方法排除，使用set，那么时间复杂度可能达不到</span><br><span class="line">         */</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int left = i + 1;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            if (sum &gt; 0) &#123;</span><br><span class="line">                right--;//如果大于零 右缩</span><br><span class="line">            &#125; else if (sum &lt; 0) &#123;</span><br><span class="line">                left++;//如果小于零，左涨</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //否则找到正确数值，录入结果集，并且左右涨缩</span><br><span class="line">                List&lt;Integer&gt; item = new ArrayList&lt;&gt;();</span><br><span class="line">                item.add(nums[i]);</span><br><span class="line">                item.add(nums[left]);</span><br><span class="line">                item.add(nums[right]);</span><br><span class="line">                result.add(item);</span><br><span class="line"></span><br><span class="line">                /**</span><br><span class="line">                 * 重点2</span><br><span class="line">                 * 去重逻辑应该放在找到一个三元组之后，对left 和 right去重</span><br><span class="line">                 * 针对这种情况，如 [-2,0,0,2,2]</span><br><span class="line">                 */</span><br><span class="line">                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="line">                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="line"></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>双指针</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 150. 逆波兰表达式求值</title>
    <url>/2022/10/14/LeetCode150/</url>
    <content><![CDATA[<blockquote>
<p>根据 逆波兰表示法，求表达式的值。<br>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
</blockquote>
<span id="more"></span>
<p>注意 两个整数之间的除法只保留整数部分。</p>
<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例1：<br>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</p>
<p>示例2：<br>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</p>
<p>示例3：<br>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：</p>
<blockquote>
<p>((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22</p>
</blockquote>
<p>提示：</p>
<p>1 &lt;&#x3D; tokens.length &lt;&#x3D; 104<br>tokens[i]是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数</p>
<p>逆波兰表达式：</p>
<ul>
<li>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</li>
<li>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</li>
<li>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</li>
<li>逆波兰表达式主要有以下两个优点：</li>
</ul>
<p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 逆波兰表达式就是后缀表达式，对人类来说，一般都是中序表达式，但是计算机使用的是栈的数据结构，所以对弈计算机来说后后续表达式相对简单</span><br><span class="line"> */</span><br><span class="line">public int evalRPN(String[] tokens) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    for (String s : tokens) &#123;</span><br><span class="line">        if (s.equals(&quot;+&quot;)) &#123;</span><br><span class="line">            stack.push(stack.pop() + stack.pop());</span><br><span class="line">        &#125; else if (s.equals(&quot;-&quot;)) &#123;</span><br><span class="line">            Integer a = stack.pop();</span><br><span class="line">            Integer b = stack.pop();</span><br><span class="line">            stack.push(b - a);</span><br><span class="line">        &#125; else if (s.equals(&quot;*&quot;)) &#123;</span><br><span class="line">            stack.push(stack.pop() * stack.pop());</span><br><span class="line">        &#125; else if (s.equals(&quot;/&quot;)) &#123;</span><br><span class="line">            Integer a = stack.pop();</span><br><span class="line">            Integer b = stack.pop();</span><br><span class="line">            stack.push(b / a);</span><br><span class="line">        &#125; else</span><br><span class="line">            //如果不是符号，直接入栈</span><br><span class="line">            stack.push(Integer.valueOf(s));</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.pop();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>逆波兰表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 160. 相交链表</title>
    <url>/2022/10/04/LeetCode160/</url>
    <content><![CDATA[<blockquote>
<p>给你两个单链表的头节点headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。<br>图示两个链表在节点 c1 开始相交：<br><img src="/../images/leetcode160/160_statement.png" alt="ing">)</p>
</blockquote>
<span id="more"></span> 

<blockquote>
<p>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须 保持其原始结构 。<br>自定义评测：<br>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p>
<ul>
<li>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0   </li>
<li>listA - 第一个链表   </li>
<li>listB - 第二个链表   </li>
<li>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数   </li>
<li>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数   </li>
<li>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据题意，求两个链表的交点节点，如果没有交点，返回null</span><br><span class="line"> * 由于链表存在交点，所以，从交点开始直到末尾，都是相同的节点</span><br><span class="line"> * 鉴于以上的原因，可以求出A、B链表的长度差N,长的链表先走N步，再 A、B一起走，直到遇到相同的节点</span><br><span class="line"> */</span><br><span class="line">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">    ListNode a = headA;</span><br><span class="line">    ListNode b = headB;</span><br><span class="line">    //求A的长度</span><br><span class="line">    int lenA = 0;</span><br><span class="line">    int lenB = 0;</span><br><span class="line">    while (a != null) &#123;</span><br><span class="line">        a = a.next;</span><br><span class="line">        lenA++;</span><br><span class="line">    &#125;</span><br><span class="line">    //求B的长度</span><br><span class="line">    while (b != null) &#123;</span><br><span class="line">        b = b.next;</span><br><span class="line">        lenB++;</span><br><span class="line">    &#125;</span><br><span class="line">    //还原A，B链表</span><br><span class="line">    a = headA;</span><br><span class="line">    b = headB;</span><br><span class="line">    //A、B交换，确保 A链表是最长的</span><br><span class="line">    if (lenA &lt; lenB) &#123;</span><br><span class="line">        int temp = lenA;</span><br><span class="line">        lenA = lenB;</span><br><span class="line">        lenB = temp;</span><br><span class="line">        ListNode node = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = node;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = lenA - lenB;</span><br><span class="line">    while (n-- &gt; 0) &#123;</span><br><span class="line">        a = a.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (a != null) &#123;</span><br><span class="line">        if (a == b) &#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a.next;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 双指针计算</span><br><span class="line"> * 解析：https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/</span><br><span class="line"> */</span><br><span class="line">public ListNode getIntersectionNode2(ListNode headA, ListNode headB) &#123;</span><br><span class="line">    if (headA == null || headB == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pA = headA, pB = headB;</span><br><span class="line">    while (pA != pB) &#123;</span><br><span class="line">        pA = pA == null ? headB : pA.next;</span><br><span class="line">        pB = pB == null ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 17. 电话号码的字母组合</title>
    <url>/2022/10/28/LeetCode17/</url>
    <content><![CDATA[<p>给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src="/../images/leetCode17/200px-telephone-keypad2svg.png"></p>
<span id="more"></span>

<p>示例 1：<br>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]  </p>
<p>示例 2：<br>输入：digits &#x3D; “”<br>输出：[]  </p>
<p>示例 3：<br>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]  </p>
<p>提示：<br>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 映射map</span><br><span class="line"> */</span><br><span class="line">public HashMap&lt;Character, String&gt; map = new HashMap&lt;Character, String&gt;() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        put(&#x27;2&#x27;, &quot;abc&quot;);</span><br><span class="line">        put(&#x27;3&#x27;, &quot;def&quot;);</span><br><span class="line">        put(&#x27;4&#x27;, &quot;ghi&quot;);</span><br><span class="line">        put(&#x27;5&#x27;, &quot;jkl&quot;);</span><br><span class="line">        put(&#x27;6&#x27;, &quot;mno&quot;);</span><br><span class="line">        put(&#x27;7&#x27;, &quot;pqrs&quot;);</span><br><span class="line">        put(&#x27;8&#x27;, &quot;tuv&quot;);</span><br><span class="line">        put(&#x27;9&#x27;, &quot;wxyz&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">    if (digits == null || digits.length() == 0) &#123;</span><br><span class="line">        return rt;</span><br><span class="line">    &#125;</span><br><span class="line">    tracking(digits, 0);</span><br><span class="line">    return rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * st</span><br><span class="line"> *</span><br><span class="line"> * @param digits 字符串</span><br><span class="line"> * @param start  字符串的下标，从零开始</span><br><span class="line"> */</span><br><span class="line">public void tracking(String digits, int start) &#123;</span><br><span class="line">    if (start == digits.length()) &#123;//已经遍历完了</span><br><span class="line">        rt.add(item);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    char c = digits.charAt(start);</span><br><span class="line">    String st = map.get(c);</span><br><span class="line">    for (char a : st.toCharArray()) &#123;</span><br><span class="line">        String temp = item;</span><br><span class="line">        item = item + a;//这里需要优化一下，不然性能有点卡</span><br><span class="line">        tracking(digits, start + 1);</span><br><span class="line">        item = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public List&lt;String&gt; rt = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public String item = new String();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 18. 四数之和</title>
    <url>/2022/10/12/LeetCode18/</url>
    <content><![CDATA[<blockquote>
<p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]]<br>（若两个四元组元素一一对应，则认为两个四元组重复）</p>
</blockquote>
<span id="more"></span>



<p>示例 1：<br>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p>
<p>示例 2：<br>输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]]</p>
<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 可以参考三数之和，其中这里多了一个条件，等于target，所以去重的时候需要考量的不一样</span><br><span class="line"> * 其实双指针就是比暴力破解减少一层循环，实际上时间复杂度就是 O(N^3)</span><br><span class="line"> */</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    //直接使用函数的排序算法，一般时间复杂度都是 O(N^2)或者O(NlogN)</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    //根据</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 3; i++) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 三数之和 可以通过 nums[i] &gt; 0 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。</span><br><span class="line">         * 比如：数组是[-4, -3, -2, -1]，target是-10，不能因为-4 &gt; -10而跳过</span><br><span class="line">         */</span><br><span class="line">        if (nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) &#123;</span><br><span class="line">            break;//统一最后的结果返回</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = i + 1; j &lt; nums.length; j++) &#123;</span><br><span class="line">            //经过排序后的数组,首数字不能大于target，不然后续就不需要遍历,这块算是折枝的手段</span><br><span class="line">            if (nums[i] + nums[j] &gt; 0 &amp;&amp; nums[i] + nums[j] &gt; target) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            /**</span><br><span class="line">             * 特别关键的步骤</span><br><span class="line">             * i 至少等于1</span><br><span class="line">             * 跟前一个数值对比，如果相等，那么就意味这可以过滤调重复的组合</span><br><span class="line">             * 反过来如果是跟后面的一个数值对比，那么就可能缺失以下的这种情况 [-1,-1,2]，这里需要细致思考</span><br><span class="line">             * 如果不用这种方法排除，使用set，那么时间复杂度可能达不到</span><br><span class="line">             */</span><br><span class="line">            if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int left = j + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                if (sum &gt; target) &#123;</span><br><span class="line">                    right--;//如果大于零 右缩</span><br><span class="line">                &#125; else if (sum &lt; target) &#123;</span><br><span class="line">                    left++;//如果小于零，左涨</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //否则找到正确数值，录入结果集，并且左右涨缩</span><br><span class="line">                    List&lt;Integer&gt; item = new ArrayList&lt;&gt;();</span><br><span class="line">                    item.add(nums[i]);</span><br><span class="line">                    item.add(nums[j]);</span><br><span class="line">                    item.add(nums[left]);</span><br><span class="line">                    item.add(nums[right]);</span><br><span class="line">                    result.add(item);</span><br><span class="line"></span><br><span class="line">                    /**</span><br><span class="line">                     * 重点2</span><br><span class="line">                     * 去重逻辑应该放在找到一个三元组之后，对left 和 right去重</span><br><span class="line">                     * 针对这种情况，如 [-2,0,0,2,2]</span><br><span class="line">                     */</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="line"></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>双指针</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 20. 有效的括号</title>
    <url>/2022/10/14/LeetCode20/</url>
    <content><![CDATA[<blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
</blockquote>
<span id="more"></span>

<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ul>
<p>示例 1：<br>输入：s &#x3D; “()”<br>输出：true</p>
<p>示例2：<br>输入：s &#x3D; “()[]{}”<br>输出：true</p>
<p>示例3：<br>输入：s &#x3D; “(]”<br>输出：false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 题目意思就是判断是否有&quot;正确的括号&quot;</span><br><span class="line"> * 1、由于括号都是有成对的出现，所以字符串必须是双数</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false</span><br><span class="line"> */</span><br><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">    if (s.length() % 2 != 0) &#123;</span><br><span class="line">        return false;//如果不为0，就不是</span><br><span class="line">    &#125;</span><br><span class="line">    //由于栈的 LIFO 特性，适合这道题</span><br><span class="line">    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    for (char c : s.toCharArray()) &#123;</span><br><span class="line">        //如果是 （ &#123; [ 这三种，需要相应入栈翻括号</span><br><span class="line">        if (c == &#x27;(&#x27;) &#123;</span><br><span class="line">            stack.push(&#x27;)&#x27;);</span><br><span class="line">        &#125; else if (c == &#x27;[&#x27;) &#123;</span><br><span class="line">            stack.push(&#x27;]&#x27;);</span><br><span class="line">        &#125; else if (c == &#x27;&#123;&#x27;) &#123;</span><br><span class="line">            stack.push(&#x27;&#125;&#x27;);</span><br><span class="line">        &#125; else if (stack.isEmpty() || c != stack.peek()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else</span><br><span class="line">            stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>栈与队列</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 1047. 删除字符串中的所有相邻重复项</title>
    <url>/2022/10/14/LeetCode1047/</url>
    <content><![CDATA[<blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
</blockquote>
<span id="more"></span>

<p>示例：<br>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。  </p>
<p>提示：<br>1 &lt;&#x3D; S.length &lt;&#x3D; 20000<br>S 仅由小写英文字母组成。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String removeDuplicates(String s) &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    for (char c : s.toCharArray()) &#123;</span><br><span class="line">        if (!stack.isEmpty() &amp;&amp; stack.peek() == c) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String r = &quot;&quot;;</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        r = stack.pop() + r;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>栈与队列</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 203. 移除链表元素</title>
    <url>/2022/10/06/LeetCode203/</url>
    <content><![CDATA[<blockquote>
<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。<br><img src="/../images/leetcode203/removelinked-list.jpg"></p>
</blockquote>
<span id="more"></span> 

<blockquote>
<p>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6<br>输出：[1,2,3,4,5]</p>
<p>输入：head &#x3D; [], val &#x3D; 1<br>输出：[]</p>
<p>输入：head &#x3D; [7,7,7,7], val &#x3D; 7<br>输出：[]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当节点的next==null就是到链表尾巴</span><br><span class="line"> *</span><br><span class="line"> * @param head</span><br><span class="line"> * @param val</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">    //初始化一个指向头结点的临时节点</span><br><span class="line">    ListNode temp = new ListNode(0, head);</span><br><span class="line">    ListNode pre = temp;</span><br><span class="line">    while (pre.next != null) &#123;</span><br><span class="line">        if (pre.next.val == val) &#123;</span><br><span class="line">            //当前节点的下一个节点赋值给前一个节点的next</span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 202. 快乐数</title>
    <url>/2022/10/10/LeetCode202/</url>
    <content><![CDATA[<blockquote>
<p>编写一个算法来判断一个数 n 是不是快乐数。<br>「快乐数」定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</li>
<li>如果这个过程 结果为 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p>
</blockquote>
<span id="more"></span>

<p>示例 1：<br>输入：n &#x3D; 19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1</p>
<p>示例 2：<br>输入：n &#x3D; 2<br>输出：false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isHappy(int n) &#123;</span><br><span class="line">    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">    while (!set.contains(n)) &#123;</span><br><span class="line">        if (n == 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(n);</span><br><span class="line">        n = getNextNum(n);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getNextNum(int n) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while (n &gt; 0) &#123;</span><br><span class="line">        int a = n % 10;//得出个位数的值</span><br><span class="line">        sum = sum + a * a;</span><br><span class="line">        n = n / 10;//个位数除于10，商为0</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>哈希表</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 102. 二叉树的层序遍历</title>
    <url>/2022/10/18/LeetCode102/</url>
    <content><![CDATA[<blockquote>
<p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。<br><img src="/../images/leetcode102/tree1.jpg"></p>
</blockquote>
<span id="more"></span>

<p>示例 1：<br>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]  </p>
<p>示例 2：<br>输入：root &#x3D; [1]<br>输出：[[1]]  </p>
<p>示例 3：<br>输入：root &#x3D; []<br>输出：[]  </p>
<p>提示：  </p>
<p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000  </p>
<p><strong>Ps</strong>：虽然题目说层序遍历，但是实际上也可以使用深度遍历，结果在收集结果集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * BFS</span><br><span class="line"> * 层序遍历使用队列实现</span><br><span class="line"> */</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();</span><br><span class="line">        int size = queue.size();//队列参数会变化，所以size需要提取出来</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode poll = queue.poll();</span><br><span class="line">            if (poll != null) &#123;</span><br><span class="line">                item.add(poll.val);</span><br><span class="line">                if (poll.left != null) &#123;</span><br><span class="line">                    queue.offer(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (poll.right != null) &#123;</span><br><span class="line">                    queue.offer(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lists.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    return lists;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 深度遍历 使用递归</span><br><span class="line"> * 递归三要素</span><br><span class="line"> * 1、确立好入参、出参</span><br><span class="line"> * 2、确立好终止条件</span><br><span class="line"> * 3、确立好递归调用函数</span><br><span class="line"> */</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; dfs(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    dfsPass(result, root, 0);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递归</span><br><span class="line"> * @param result 确立结果</span><br><span class="line"> * @param root   树当前节点</span><br><span class="line"> * @param deepth 深度</span><br><span class="line"> */</span><br><span class="line">public static void dfsPass(List&lt;List&lt;Integer&gt;&gt; result, TreeNode root, int deepth) &#123;</span><br><span class="line">    if (root == null) &#123;//结束条件</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    deepth++;//元素不为空，这里增加1</span><br><span class="line">    if (result.size() &lt; deepth) &#123;</span><br><span class="line">        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();//结果集需要加1</span><br><span class="line">        result.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    result.get(deepth - 1).add(root.val);//添加当前元素</span><br><span class="line">    dfsPass(result, root.left, deepth);//深度前面已经+1，这里无序再加</span><br><span class="line">    dfsPass(result, root.right, deepth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 206. 反转链表</title>
    <url>/2022/10/06/LeetCode206/</url>
    <content><![CDATA[<blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
</blockquote>
<span id="more"></span> 

<blockquote>
<p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br><img src="/../images/leetcode206/rev1ex1.jpg"></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 如题，链表翻转，可以定义一个前置节点，默认是default = null</span><br><span class="line"> */</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode prev = null;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        ListNode temp = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 216. 组合总和 III</title>
    <url>/2022/10/28/LeetCode216/</url>
    <content><![CDATA[<p>找出所有相加之和为n 的k个数的组合，且满足下列条件：  </p>
<ul>
<li>只使用数字1到9  </li>
<li>每个数字最多使用一次</li>
</ul>
<p>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。  </p>
<span id="more"></span>

<p>示例 1:<br>输入: k &#x3D; 3, n &#x3D; 7<br>输出: [[1,2,4]]<br>解释:<br>1 + 2 + 4 &#x3D; 7<br>没有其他符合的组合了。  </p>
<p>示例 2:<br>输入: k &#x3D; 3, n &#x3D; 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]<br>解释:<br>1 + 2 + 6 &#x3D; 9<br>1 + 3 + 5 &#x3D; 9<br>2 + 3 + 4 &#x3D; 9<br>没有其他符合的组合了。  </p>
<p>示例 3:<br>输入: k &#x3D; 4, n &#x3D; 1<br>输出: []<br>解释: 不存在有效的组合。<br>在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 &#x3D; 10，因为10 &gt; 1，没有有效的组合。  </p>
<p>提示:<br>2 &lt;&#x3D; k &lt;&#x3D; 9<br>1 &lt;&#x3D; n &lt;&#x3D; 60  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 简单理解就是 k个数之和等于n</span><br><span class="line"> */</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">    tracking(k, n, 1);</span><br><span class="line">    return rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 回溯递归</span><br><span class="line"> * 1、需要一个装载数据的容器</span><br><span class="line"> * 2、需要一个装载结果集合的容器</span><br><span class="line"> * 3、需要统计相加目前的值 sum;</span><br><span class="line"> */</span><br><span class="line">public void tracking(int k, int n, int stId) &#123;</span><br><span class="line">    if (sum &gt; n) &#123;//目前的数值大于n，返回上一层</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (item.size() == k &amp;&amp; sum == n) &#123;//符合条件，装载结果集</span><br><span class="line">        rt.add(new ArrayList&lt;&gt;(item));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = stId; i &lt; 10 - (k - item.size()) + 1; i++) &#123;//题目限制了 1~9</span><br><span class="line">        item.offer(i);</span><br><span class="line">        sum += i;</span><br><span class="line">        tracking(k, n, i + 1);</span><br><span class="line">        item.removeLast();//回溯</span><br><span class="line">        sum -= i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private List&lt;List&lt;Integer&gt;&gt; rt = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">private LinkedList&lt;Integer&gt; item = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">private int sum = 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 225. 用队列实现栈</title>
    <url>/2022/10/14/LeetCode225/</url>
    <content><![CDATA[<blockquote>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
</blockquote>
<span id="more"></span>

<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<p>注意：</p>
<ul>
<li>你只能使用队列的基本操作 —— 也就是push to back、peek&#x2F;pop from front、size 和is empty这些操作。  </li>
<li>你所使用的语言也许不支持队列。你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列, 只要是标准的队列操作即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LeetCode225 &#123;</span><br><span class="line"></span><br><span class="line">    private Queue&lt;Integer&gt; queueA = new LinkedList&lt;&gt;();</span><br><span class="line">    private Queue&lt;Integer&gt; queueB = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 其实就是将B队列做一个备份队列</span><br><span class="line">     */</span><br><span class="line">    public LeetCode225() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这里标星，需要重点思考</span><br><span class="line">     * 1、每次入栈都是先进入 B 队列，然后将A队列的值放到B</span><br><span class="line">     * 2、将A、B队列交互</span><br><span class="line">     * * 此刻，A队列的队首相当于 栈的顶部，队尾巴相当于 栈的底部</span><br><span class="line">     */</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        queueB.offer(x);//想B队列入队</span><br><span class="line">        while (!queueA.isEmpty()) &#123;</span><br><span class="line">            queueB.offer(queueA.poll());//将A队列的元素全部放到B队列</span><br><span class="line">        &#125;</span><br><span class="line">        //通过交换，此刻 A队列的元素永远是栈的元素</span><br><span class="line">        Queue&lt;Integer&gt; temp = queueA;</span><br><span class="line">        queueA = queueB;</span><br><span class="line">        queueB = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除最后入队的的元素</span><br><span class="line">     */</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return queueA.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查看栈顶元素</span><br><span class="line">     */</span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return queueA.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 只需要判断A队列是否空</span><br><span class="line">     */</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return queueA.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 209. 长度最小的子数组</title>
    <url>/2022/10/06/LeetCode209/</url>
    <content><![CDATA[<blockquote>
<p>给定一个含有n个正整数的数组和一个正整数 target 。<br>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组[numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。  </p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<p>输入：target &#x3D; 4, nums &#x3D; [1,4,4]<br>输出：1</p>
<p>输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]<br>输出：0</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 1、最应该想到的是暴力破解，一层外循环遍历所有字符，一层内循环遍历得到的子数组，明显时间复杂度 O（n^2）</span><br><span class="line"> * 2、滑动窗口，其实就是双指针，在指针范围内的子数组，满足target，并不断的调节子左右指针，额外的变量纪录窗口的最小值</span><br><span class="line"> */</span><br><span class="line">public int minSubArrayLen(int target, int[] nums) &#123;</span><br><span class="line">    int l = 0;</span><br><span class="line">    int r = 0;</span><br><span class="line">    int sum = 0;//窗口的值</span><br><span class="line">    int min = Integer.MAX_VALUE;</span><br><span class="line">    //右指针到达数组结尾即结束</span><br><span class="line">    while (r &lt; nums.length) &#123;</span><br><span class="line">        sum = sum + nums[r];</span><br><span class="line">        //外循环 r指针不断的往右增加值</span><br><span class="line">        while (sum &gt;= target) &#123;</span><br><span class="line">            //内循环 l指针不断的往右缩减</span><br><span class="line">            min = Math.min(r - l + 1, min);</span><br><span class="line">            sum = sum - nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    return min == Integer.MAX_VALUE ? 0 : min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 24. 两两交换链表中的节点</title>
    <url>/2022/10/03/LeetCode24/</url>
    <content><![CDATA[<blockquote>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]</p>
<p>输入：head &#x3D; []<br>输出：[]</p>
<p>输入：head &#x3D; [1]<br>输出：[1]  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 如：</span><br><span class="line"> * cur&gt;1&gt;2&gt;3&gt;4&gt;5&gt;6</span><br><span class="line"> * 1、cur&gt;2</span><br><span class="line"> * 2、2&gt;1</span><br><span class="line"> * 3、1&gt;3</span><br><span class="line"> * 第一轮结果 cur&gt;2&gt;1&gt;3&gt;4&gt;5&gt;6</span><br><span class="line"> * cur = cur.next.next;</span><br><span class="line"> * 当前cur&gt;3&gt;4&gt;5&gt;6</span><br><span class="line"> */</span><br><span class="line">public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">    ListNode dummp = new ListNode(0, head);</span><br><span class="line">    ListNode cur = dummp;</span><br><span class="line">    while (cur.next != null &amp;&amp; cur.next.next != null) &#123;</span><br><span class="line">        ListNode one = cur.next;</span><br><span class="line">        ListNode two = cur.next.next;</span><br><span class="line">        ListNode three = cur.next.next.next;</span><br><span class="line">        cur.next = two;</span><br><span class="line">        two.next = one;</span><br><span class="line">        one.next = three;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return dummp.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 232. 用栈实现队列</title>
    <url>/2022/10/14/LeetCode232/</url>
    <content><![CDATA[<blockquote>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）</p>
</blockquote>
<span id="more"></span>
<blockquote>
</blockquote>
<p>实现 MyQueue 类：</p>
<ul>
<li>void push(int x) 将元素 x 推到队列的末尾  </li>
<li>int pop() 从队列的开头移除并返回元素  </li>
<li>int peek() 返回队列开头的元素  </li>
<li>boolean empty() 如果队列为空，返回 true ；否则，返回 false  </li>
<li>说明：</li>
</ul>
<p>你 只能 使用标准的栈操作 —— 也就是只有push to top,peek&#x2F;pop from top,size, 和is empty操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。  </p>
<p>示例 1：  </p>
<p>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]  </p>
<p>解释：<br>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false  </p>
<p>提示：  </p>
<p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用 100 次 push、pop、peek 和 empty<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）  </p>
<p>进阶：  </p>
<blockquote>
<p>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class LeetCode232 &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化</span><br><span class="line">     * 思路：使用两个栈实现队列</span><br><span class="line">     */</span><br><span class="line">    public LeetCode232() &#123;</span><br><span class="line">        stackIn = new Stack();</span><br><span class="line">        stackOut = new Stack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入栈</span><br><span class="line">     * 只需要把元素放到 “入栈” 的栈里面</span><br><span class="line">     */</span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除并获得一个元素</span><br><span class="line">     * 思路：需要先将“入栈”的元素放到“出栈”的栈里面，才能获取一个元素，队里是 FIFO</span><br><span class="line">     */</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        dumpStackIn();</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获得一个元素，不删除，思考对比pop</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        dumpStackIn();</span><br><span class="line">        return stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断队列是否为空</span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果出栈空，就从入栈弹出一个元素</span><br><span class="line">     */</span><br><span class="line">    private void dumpStackIn() &#123;</span><br><span class="line">        if (!stackOut.isEmpty()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //需要将目前所有的“入栈”的元素都放到“出栈”里面 不然无法做到FIFO</span><br><span class="line">        while (!stackIn.isEmpty()) &#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>栈与队列</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 236. 二叉树的最近公共祖先</title>
    <url>/2022/10/24/LeetCode236/</url>
    <content><![CDATA[<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<span id="more"></span>

<p>示例 1：<br><img src="/../images/leetcode236/binarytree.png"></p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p>
<p>示例 2：<br><img src="/../images/leetcode236/binarytree.png"></p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>示例 3：<br>输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>输出：1</p>
<p>提示：</p>
<p>树中节点数目在范围 [2, 10^5] 内。<br>-10^9 &lt;&#x3D; Node.val &lt;&#x3D; 10^9<br>所有 Node.val 互不相同 。<br>p !&#x3D; q<br>p 和 q 均存在于给定的二叉树中。</p>
<blockquote>
<p>实在话，这道题代码量不大，但是也挺考验个人的空间思维能力，而且使用迭代法会复杂很多。<br>面试考到的几率估计会大点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 查询最近公共祖先，最好是能从下到上遍历树，后序遍历就是目的</span><br><span class="line"> * 假如在遍历的过程中，左右节点都能找到，不为空，那么当前的中节点就是他们的最小公共祖先</span><br><span class="line"> */</span><br><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    //当找到对应的节点，那么就返回，null节点返回空,由于每个节点遍历一次，所以这里的不会出现root==p等下又遇到的情况</span><br><span class="line">    if (root == p || root == q || root == null) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    //左</span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    //右</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    if (left != null &amp;&amp; right != null) &#123;//左右节点都找到值，返回当前节点</span><br><span class="line">        return root;</span><br><span class="line">    &#125; else if (right == null) &#123;//如果右节点为空就返回 左节点</span><br><span class="line">        return left;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return right;//否则返回右节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 222. 完全二叉树的节点个数</title>
    <url>/2022/10/19/LeetCode222/</url>
    <content><![CDATA[<blockquote>
<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~2^h个节点。</p>
</blockquote>
<p>示例 1：<br><img src="/../images/leetcode222/complete.jpg"></p>
<p>输入：root &#x3D; [1,2,3,4,5,6]<br>输出：6  </p>
<p>示例 2：<br>输入：root &#x3D; []<br>输出：0  </p>
<p>示例 3：<br>输入：root &#x3D; [1]<br>输出：1  </p>
<p>提示：</p>
<p>树中节点的数目范围是[0, 5 * 104]<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 5 * 104<br>题目数据保证输入的树是 完全二叉树  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 222. 完全二叉树的节点个数</span><br><span class="line"> */</span><br><span class="line">public class LeetCode222 &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 题目里面说到求完全二叉树的节点个数，如果单纯是求二叉树的个数，我们很容易想到 BFS、DFS</span><br><span class="line">     * 但是题目说到是完全二叉树，那么就有完全二叉树的特点</span><br><span class="line">     */</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        return dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 年轻人不讲武德 之 DFS</span><br><span class="line">     */</span><br><span class="line">    public int dfs(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //左子树的节点+右子树的节点+头节点</span><br><span class="line">        return dfs(root.left) + dfs(root.right) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 简单的 bfs</span><br><span class="line">     */</span><br><span class="line">    public int bfs(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; qe = new LinkedList&lt;&gt;();</span><br><span class="line">        qe.offer(root);</span><br><span class="line">        int num = 0;</span><br><span class="line">        while (!qe.isEmpty()) &#123;</span><br><span class="line">            int size = qe.size();</span><br><span class="line">            while (size-- &gt; 0) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                TreeNode node = qe.poll();</span><br><span class="line">                if (node.left != null) qe.offer(node.left);</span><br><span class="line">                if (node.right != null) qe.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 此题本意 是利用完全二叉树的特性进行</span><br><span class="line">     */</span><br><span class="line">    public int realSource(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = getDepth(root.left);</span><br><span class="line">        int rigth = getDepth(root.right);</span><br><span class="line">        if (left == rigth) &#123;//如果相等，那么左子树就是满二叉树，满二叉树 = 2^n-1</span><br><span class="line">            //2^left其实是 （2^left - 1） + 1 ，左子树 + 根结点,同时 2^n = (1&lt;&lt;n)</span><br><span class="line">            return (1 &lt;&lt; left) + realSource(root.right);</span><br><span class="line">        &#125; else &#123;//不相等，那么右子树就是满二叉树，这两句话得要好好体会~~~</span><br><span class="line">            return (1 &lt;&lt; rigth) + realSource(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取深度就不断的查看左节点</span><br><span class="line">     */</span><br><span class="line">    public int getDepth(TreeNode root) &#123;</span><br><span class="line">        int num = 0;</span><br><span class="line">        while (root != null) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 27. 移除元素</title>
    <url>/2022/10/03/LeetCode27/</url>
    <content><![CDATA[<blockquote>
<p>给你一个数组 nums和一个值 val，你需要 原地 移除所有数值等于val的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。  </p>
</blockquote>
<span id="more"></span>

<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<blockquote>
<p>&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len &#x3D; removeElement(nums, val);  </p>
<p>&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。<br>&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br>for (int i &#x3D; 0; i &lt; len; i++) {<br>print(nums[i]);<br>}  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 可以使用双指针，匹配 l 针当前值是否等于 val ，相等就将 r 指针的值赋给 l，r指针往左移动一个，l 指针往右移动一格</span><br><span class="line"> * 如果r指针的值等于 val，r指针左移动</span><br><span class="line"> * 直到 l，r 指针相遇，程序结束，输出l-1指针的值，就是现在数组的长度(l多走了一格)</span><br><span class="line"> */</span><br><span class="line">public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">    //定义左右指针</span><br><span class="line">    int l = 0;</span><br><span class="line">    int r = nums.length - 1;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        //左边指针</span><br><span class="line">        while (nums[l] == val &amp;&amp; l &lt; r) &#123;</span><br><span class="line">            //右指针移动到不是val的位置</span><br><span class="line">            while (nums[r] == val &amp;&amp; l &lt; r) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            //左右指针值交换</span><br><span class="line">//                swap(nums[l], nums[r]);</span><br><span class="line">            int temp = nums[l];</span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">            nums[r] = temp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    return l - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快慢指针，快指针会跳过值等于val的元素，不等于val值的元素会赋给慢指针的位置，当快指针到达数组底部，慢指针的位置就是数组的长度</span><br><span class="line"> *</span><br><span class="line"> * @param nums</span><br><span class="line"> * @param val</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int fastShowPoint(int[] nums, int val) &#123;</span><br><span class="line">    int show = 0;</span><br><span class="line">    for (int fast = 0; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">        if (nums[fast] != val) &#123;</span><br><span class="line">            //当快指针的值不等于val，则赋给慢指针</span><br><span class="line">            nums[show] = nums[fast];</span><br><span class="line">            show++;//分开两步，思路清晰</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return show;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 257. 二叉树的所有路径</title>
    <url>/2022/10/21/LeetCode257/</url>
    <content><![CDATA[<p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。<br>叶子节点 是指没有子节点的节点。   </p>
<span id="more"></span>

<p>示例 1：<br><img src="/../images/leetcode257/paths-tree.jpg"></p>
<p>输入：root &#x3D; [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]  </p>
<p>示例 2：<br>输入：root &#x3D; [1]<br>输出：[“1”]</p>
<p>提示：</p>
<ul>
<li>树中节点的数目在范围 [1, 100] 内  </li>
<li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li>
</ul>
<blockquote>
<p><strong>Ps</strong> 由于每个节点都只操作一次，时间复杂度是 O(N)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 典型的递归回溯题</span><br><span class="line"> * 只是题目需要返回-&gt;的字符串，就有点太多此一举</span><br><span class="line"> */</span><br><span class="line">public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(root);</span><br><span class="line">    order(list, root, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void order(List&lt;TreeNode&gt; list, TreeNode root, List&lt;String&gt; result) &#123;</span><br><span class="line">    //判断左右节点等于空而不是当前节点，可以省略当前节点进入循环，以免造成更加复杂混乱的写法</span><br><span class="line">    if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">        if (list != null &amp;&amp; list.size() &gt; 0) &#123;</span><br><span class="line">            StringBuilder builder = new StringBuilder();</span><br><span class="line">            for (TreeNode node : list) &#123;</span><br><span class="line">                builder.append(node.val).append(&quot;-&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(builder.substring(0, builder.length() - 2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left != null) &#123;</span><br><span class="line">        list.add(root.left);</span><br><span class="line">        order(list, root.left, result);</span><br><span class="line">        list.remove(root.left);//回溯，需要把加入的都剔除，不然结果会重复</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right != null) &#123;</span><br><span class="line">        list.add(root.right);</span><br><span class="line">        order(list, root.right, result);</span><br><span class="line">        list.remove(root.right);//回溯，需要把加入的都剔除，不然结果会重复</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
        <category>回溯</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 242. 有效的字母异位词</title>
    <url>/2022/10/10/LeetCode242/</url>
    <content><![CDATA[<blockquote>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>注意：若s 和 t中每个字符出现的次数都相同，则称s 和 t互为字母异位词。</p>
<p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true</p>
<p>输入: s &#x3D; “rat”, t &#x3D; “car”<br>输出: false</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一般判断是否有数字存在存在过，都是使用哈希映射</span><br><span class="line"> * 一般的映射包括 数组、set、哈希表</span><br><span class="line"> * 本题目较简单，仅仅使用数组即可解决</span><br><span class="line"> * 由于使用题目说道只是小写字母，所以就需要一个额外存储空间，大小为26的数组</span><br><span class="line"> * 1、将 s 串字符拆分放到数组中，相同字符，数字+1</span><br><span class="line"> * 2、将 t 串字符拆分遍历，判断在数组中数字-1</span><br><span class="line"> * 3、判断数组各项值是否都是0</span><br><span class="line"> */</span><br><span class="line">public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">    int[] temp = new int[26];</span><br><span class="line">    char[] chars = s.toCharArray();</span><br><span class="line">    for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">        char aChar = chars[i];</span><br><span class="line">        int a = aChar - &#x27;a&#x27;;//a为最小的下标，初始值0</span><br><span class="line">        temp[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    char[] chart = t.toCharArray();</span><br><span class="line">    for (int i = 0; i &lt; chart.length; i++) &#123;</span><br><span class="line">        int b = chart[i] - &#x27;a&#x27;;</span><br><span class="line">        temp[b]--;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; temp.length; i++) &#123;</span><br><span class="line">        if (temp[i] != 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>哈希表</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2022/10/03/LeetCode34/</url>
    <content><![CDATA[<blockquote>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回[-1, -1]。<br>你必须设计并实现时间复杂度为O(log n) 的算法解决此问题。  </p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]  </p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]</p>
<p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这道题要用二分法找到左边的开始位置，以及右边的结束位置</span><br><span class="line"> * 同时需要考虑，target不在数组中</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 情况一：target 在数组范围的右边或者左边，例如数组&#123;3, 4, 5&#125;，target为2或者数组&#123;3, 4, 5&#125;,target为6，此时应该返回&#123;-1, -1&#125;</span><br><span class="line"> * 情况二：target 在数组范围中，且数组中不存在target，例如数组&#123;3,6,7&#125;,target为5，此时应该返回&#123;-1, -1&#125;</span><br><span class="line"> * 情况三：target 在数组范围中，且数组中存在target，例如数组&#123;3,6,7&#125;,target为6，此时应该返回&#123;1, 1&#125;</span><br><span class="line"> */</span><br><span class="line">public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">    if (nums.length == 0) &#123;</span><br><span class="line">        return new int[]&#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    int rithtIndex = rithtIndex(nums, target);</span><br><span class="line">    int leftIndex = leftIndex(nums, target);</span><br><span class="line">    if (rithtIndex == -2 || leftIndex == -2) &#123;</span><br><span class="line">        return new int[]&#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rithtIndex - leftIndex &gt; 1) return new int[]&#123;leftIndex + 1, rithtIndex - 1&#125;;</span><br><span class="line">    return new int[]&#123;-1, -1&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int rithtIndex(int[] nums, int target) &#123;</span><br><span class="line">    int l = 0;</span><br><span class="line">    int r = nums.length - 1;</span><br><span class="line">    int rithtIndex = -2;</span><br><span class="line">    while (l &lt;= r) &#123;</span><br><span class="line">        int mid = l + (r - l) / 2;</span><br><span class="line">        if (nums[mid] &gt; target) &#123;//一直缩小右边界</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">            rithtIndex = l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return rithtIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int leftIndex(int[] nums, int target) &#123;</span><br><span class="line">    int l = 0;</span><br><span class="line">    int r = nums.length - 1;</span><br><span class="line">    int leftIndex = -2;</span><br><span class="line">    while (l &lt;= r) &#123;</span><br><span class="line">        int mid = l + (r - l) / 2;</span><br><span class="line">        if (nums[mid] &lt; target) &#123;//一直缩小右边界</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">            leftIndex = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return leftIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 349. 两个数组的交集</title>
    <url>/2022/10/10/LeetCode349/</url>
    <content><![CDATA[<blockquote>
<p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]</p>
<p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[9,4]<br>解释：[4,9] 也是可通过的  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 题目中，输出结果是唯一的，所以自然应该想要哈希中的 set（去重）</span><br><span class="line"> */</span><br><span class="line">public int[] intersection(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    if (nums1.length == 0 || nums2.length == 0) &#123;</span><br><span class="line">        return new int[0];</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Integer&gt; a = new HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; result = new HashSet&lt;&gt;();</span><br><span class="line">    for (int i : nums1) &#123;</span><br><span class="line">        a.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i : nums2) &#123;</span><br><span class="line">        //如果a 包含i 则放到结果集</span><br><span class="line">        if (a.contains(i)) &#123;</span><br><span class="line">            result.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>哈希表</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 367. 有效的完全平方数</title>
    <url>/2022/10/06/LeetCode367/</url>
    <content><![CDATA[<blockquote>
<p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。<br>进阶：不要 使用任何内置的库函数，如 sqrt 。  </p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>输入：num &#x3D; 16<br>输出：true</p>
<p>输入：num &#x3D; 14<br>输出：false</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 由于是正整数，所以可以理解为是正有序的，使用二分法高效</span><br><span class="line"> * 完全平方数，可以理解为，能找到一个正整数，完全满足 N*N=num</span><br><span class="line"> */</span><br><span class="line">public boolean isPerfectSquare(int num) &#123;</span><br><span class="line">    int l = 0;</span><br><span class="line">    int r = num;</span><br><span class="line">    while (l &lt;= r) &#123;</span><br><span class="line">        int mid = l + (r - l) / 2;</span><br><span class="line">        long temp = (long) mid * mid;</span><br><span class="line">        if (temp &gt; num) &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125; else if (temp &lt; num) &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 383. 赎金信</title>
    <url>/2022/10/11/LeetCode383/</url>
    <content><![CDATA[<blockquote>
<p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。<br>如果可以，返回 true ；否则返回 false 。<br>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
</blockquote>
<span id="more"></span>
<p>示例 1：<br>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出：false  </p>
<p>示例 2：<br>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出：false  </p>
<p>示例 3：<br>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出：true  </p>
<p>提示：<br>1 &lt;&#x3D; ransomNote.length, magazine.length &lt;&#x3D; 10^5<br>ransomNote 和 magazine 由小写英文字母组成  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这道题也相对简单，只需要使用一个map，纪录 magazine里面出现字符的数量，在一个for 循环ransomnote即可</span><br><span class="line"> */</span><br><span class="line">public boolean canConstruct(String ransomNote, String magazine) &#123;</span><br><span class="line">    //根据题意，使用map</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    char[] chars = magazine.toCharArray();</span><br><span class="line">    for (char c : chars) &#123;</span><br><span class="line">        if (map.containsKey(c)) &#123;</span><br><span class="line">            map.put(c, map.get(c) + 1);//存在value+1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(c, 1);//不存在插入</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    char[] chars1 = ransomNote.toCharArray();</span><br><span class="line">    for (char d : chars1) &#123;</span><br><span class="line">        if (map.containsKey(d)) &#123;</span><br><span class="line">            map.put(d, map.get(d) - 1);//如果存在，扣减1</span><br><span class="line">            if (map.get(d) == 0) &#123;</span><br><span class="line">                map.remove(d);//如果数值变成0，删除</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 39. 组合总和</title>
    <url>/2022/10/31/LeetCode39/</url>
    <content><![CDATA[<p>给你一个 无重复元素 的整数数组candidates 和一个目标整数target，找出candidates中可以使数字和为目标数target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p>对于给定的输入，保证和为target 的不同组合数少于 150 个。</p>
<span id="more"></span>


<p>示例1：<br>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。  </p>
<p>示例2：<br>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]  </p>
<p>示例 3：<br>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []  </p>
<p>提示：  </p>
<ul>
<li>1 &lt;&#x3D; candidates.length &lt;&#x3D; 30  </li>
<li>2 &lt;&#x3D; candidates[i] &lt;&#x3D; 40  </li>
<li>candidates 的所有元素 互不相同  </li>
<li>1 &lt;&#x3D; target &lt;&#x3D; 40</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 本题的要求是当前元素可以重复使用，那么递归的时候只需要把自身下标传进去就可以了</span><br><span class="line"> * 同样也需要一个结果集，装载目前数字的小集合</span><br><span class="line"> */</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">    tracking(candidates, target, 0);</span><br><span class="line">    return rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void tracking(int[] candidates, int target, int startId) &#123;</span><br><span class="line">    if (sum &gt; target) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum == target) &#123;</span><br><span class="line">        rt.add(new ArrayList&lt;&gt;(items));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = startId; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        items.offer(candidates[i]);</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        tracking(candidates, target, i);//此处是关键点，因为集合的元素可以重复使用，用这里是i而不是i+1</span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        items.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 结果集</span><br><span class="line"> */</span><br><span class="line">private List&lt;List&lt;Integer&gt;&gt; rt = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 小集合，用来回溯使用的（使用双端队列比较好操作）</span><br><span class="line"> */</span><br><span class="line">private LinkedList&lt;Integer&gt; items = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用额外的sum，简化计算</span><br><span class="line"> */</span><br><span class="line">private int sum = 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
        <category>回溯</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 40. 组合总和 II</title>
    <url>/2022/10/31/LeetCode40/</url>
    <content><![CDATA[<p>给定一个候选人编号的集合candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。  </p>
<p>candidates中的每个数字在每个组合中只能使用一次。  </p>
<p>注意：解集不能包含重复的组合。  </p>
<span id="more"></span>

<p>示例1:<br>输入: candidates &#x3D;[10,1,2,7,6,1,5], target &#x3D;8,<br>输出:<br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]</p>
<p>示例2:<br>输入: candidates &#x3D;[2,5,2,1,2], target &#x3D;5,<br>输出:<br>[<br>[1,2,2],<br>[5]<br>]</p>
<p>提示:</p>
<ul>
<li>1 &lt;&#x3D;candidates.length &lt;&#x3D; 100   </li>
<li>1 &lt;&#x3D;candidates[i] &lt;&#x3D; 50  </li>
<li>1 &lt;&#x3D; target &lt;&#x3D; 30</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 这题有点 hard的 标星</span><br><span class="line"> * 这道题跟39有点不一样，因为集合里面的元素是有重复的，所以需要解决两个问题</span><br><span class="line"> * 1、数组元素是重复的，怎么解决相同的集合（事后使用set去重，效率有低效）</span><br><span class="line"> * 2、如何结局 （2，6），（6，2） 这种重复集合的问题？可以使用排序后的数组</span><br><span class="line"> */</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">    if (candidates == null || candidates.length == 0) &#123;</span><br><span class="line">        return rt;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(candidates);//转成有序数组</span><br><span class="line">    user = new boolean[candidates.length];//需要一个额外空间保存数值是否有使用过</span><br><span class="line">    Arrays.fill(user, false);//初始化数值</span><br><span class="line">    tracking(candidates, target, 0);</span><br><span class="line">    return rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void tracking(int[] candidates, int target, int startId) &#123;</span><br><span class="line">    if (sum &gt; target) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum == target) &#123;</span><br><span class="line">        rt.add(new ArrayList&lt;&gt;(items));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = startId; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br><span class="line">        // used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br><span class="line">        // 要对同一树层使用过的元素进行跳过</span><br><span class="line">        if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; user[i - 1] == false) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        user[i] = true;</span><br><span class="line">        items.offer(candidates[i]);</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        tracking(candidates, target, i + 1);//因为元素不能重复使用，所以需要调用下一个</span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        items.removeLast();</span><br><span class="line">        user[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private List&lt;List&lt;Integer&gt;&gt; rt = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">private LinkedList&lt;Integer&gt; items = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">private boolean[] user = new boolean[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 题数值大于0</span><br><span class="line"> */</span><br><span class="line">private int sum = 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>回溯</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 28. 找出字符串中第一个匹配项的下标</title>
    <url>/2022/10/13/LeetCode28/</url>
    <content><![CDATA[<blockquote>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。</p>
</blockquote>
<span id="more"></span>

<p>示例 1：<br>输入：haystack &#x3D; “sadbutsad”, needle &#x3D; “sad”<br>输出：0<br>解释：”sad” 在下标 0 和 6 处匹配。<br>第一个匹配项的下标是 0 ，所以返回 0 。  </p>
<p>示例 2：<br>输入：haystack &#x3D; “leetcode”, needle &#x3D; “leeto”<br>输出：-1<br>解释：”leeto” 没有在 “leetcode” 中出现，所以返回 -1 。  </p>
<p>提示：<br>1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 104<br>haystack 和 needle 仅由小写英文字符组成  </p>
<blockquote>
<p>典型的KMP算法题，初次接触，只有一面懵逼</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LeetCode28 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LeetCode28 leetCode28 = new LeetCode28();</span><br><span class="line">        int i = leetCode28.strStr(&quot;klofefegre&quot;, &quot;fef&quot;);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果单纯是暴力算法，那么时间复杂度是 O（n*m） 文本串以及模式串，所以需要使用KMP算法</span><br><span class="line">     * KMP题目，主要是构建 next 数组，就是回退数组、前缀表，用于帮助当前函数哪里需要回退使用的</span><br><span class="line">     * 主函数的推算跟next数组的构建类似，也是主要是三部</span><br><span class="line">     * 1、初始化起始值</span><br><span class="line">     * 2、处理字符不匹配的情况</span><br><span class="line">     * 3、处理字符匹配的情况</span><br><span class="line">     */</span><br><span class="line">    public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        if (haystack.length() == 0 || needle.length() == 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] next = new int[needle.length()];//定义一个next数组，长度为模式串的长度</span><br><span class="line">        getNext(next, needle);//初始化next数组</span><br><span class="line">        int j = -1;//模式串的起始位置，因为数组里面的最低是-1</span><br><span class="line">        for (int i = 0; i &lt; haystack.length(); i++) &#123;//文本串直接从0开始</span><br><span class="line">            //处理不相等的情况</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; haystack.charAt(i) != needle.charAt(j + 1)) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            //处理相等的情况</span><br><span class="line">            if (haystack.charAt(i) == needle.charAt(j + 1)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断是否已经结束,j+1已经到模式串的末尾</span><br><span class="line">            if (j + 1 == needle.length()) &#123;</span><br><span class="line">                return i - needle.length() + 1;//末尾需要文本串减去模式串 再 +1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据模式寸在数组 next 中赋值</span><br><span class="line">     * 1、初始化起始值，定义 j，i变量，j为前缀末，i为后缀末</span><br><span class="line">     * 2、前缀末与后缀末不相等的情况</span><br><span class="line">     * 3、前缀末与后缀末相等的情况</span><br><span class="line">     * 如 s = aabaaf;</span><br><span class="line">     */</span><br><span class="line">    public static void getNext(int[] next, String s) &#123;</span><br><span class="line">        int j = -1;//使用next数组，起始值-1，主要是避免数值为0，循环超出数组的问题</span><br><span class="line">        next[0] = j;</span><br><span class="line">        for (int i = 1; i &lt; s.length(); i++) &#123;//由于j已经是第一个值，那么i从坐标1开始</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j + 1)) &#123;//由于j初始-1，所以这里需要+1</span><br><span class="line">                j = next[j];//如果不相等，j需要回推到next[j]所指的下标</span><br><span class="line">            &#125;</span><br><span class="line">            if (s.charAt(i) == s.charAt(j + 1)) &#123;//处理相等的情况</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;//只有i是每次都递增1，j是不断变化的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 404. 左叶子之和</title>
    <url>/2022/10/21/LeetCode404/</url>
    <content><![CDATA[<p>给定二叉树的根节点 root，返回所有左叶子之和。</p>
<span id="more"></span>

<p>示例 1：</p>
<p><img src="/../images/leetcode404/leftsum-tree.jpg">  </p>
<p>输入: root &#x3D; [3,9,20,null,null,15,7]<br>输出: 24<br>解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24  </p>
<p>示例2:<br>输入: root &#x3D; [1]<br>输出: 0  </p>
<p>提示:<br>节点数在[1, 1000]范围内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根节点不是叶子节点</span><br><span class="line"> */</span><br><span class="line">public int sumOfLeftLeaves(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">        return 0;//这步要主要，当前节点没有孩子节点，所以当前节点是叶子节点，应该返回0</span><br><span class="line">    &#125;</span><br><span class="line">    int leftint = sumOfLeftLeaves(root.left);</span><br><span class="line">    if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) &#123;//判断当节点的左节点是否是叶子节点</span><br><span class="line">        leftint = leftint + root.left.val;</span><br><span class="line">    &#125;</span><br><span class="line">    int rightint = sumOfLeftLeaves(root.right);</span><br><span class="line">    return leftint + rightint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 454. 四数相加 II</title>
    <url>/2022/10/11/LeetCode454/</url>
    <content><![CDATA[<blockquote>
<p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>
<ul>
<li>0 &lt;&#x3D; i, j, k, l &lt; n</li>
<li>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</li>
</ul>
</blockquote>
<span id="more"></span>
<blockquote>
</blockquote>
<p>示例 1：<br>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]<br>输出：2<br>解释：<br>两个元组如下：</p>
<ol>
<li>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0  </li>
<li>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li>
</ol>
<p>示例 2：<br>输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]<br>输出：1  </p>
<p>提示：<br>n &#x3D;&#x3D; nums1.length<br>n &#x3D;&#x3D; nums2.length<br>n &#x3D;&#x3D; nums3.length<br>n &#x3D;&#x3D; nums4.length<br>1 &lt;&#x3D; n &lt;&#x3D; 200<br>-228 &lt;&#x3D; nums1[i], nums2[i], nums3[i], nums4[i] &lt;&#x3D; 228  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 首先承认是看过来解题思路</span><br><span class="line">  * 如果这道题直接暴力破解，得要四层for循环 时间复杂度O(N^4),明显是超出时间限制</span><br><span class="line">  * 但是这题又不像是两数相加，只需要一层N就可以</span><br><span class="line">  * 所以需要分组，两两一组，分别是两个for循环( O(2*N^2) 也就是等于O(N^2))</span><br><span class="line">  * 由于题目是查询组合，所有，必须要有map纪录，value的次数</span><br><span class="line">  */</span><br><span class="line"> public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123;</span><br><span class="line">     HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">     for (int a : nums1) &#123;</span><br><span class="line">         for (int b : nums2) &#123;</span><br><span class="line">             int sum = a + b;</span><br><span class="line">             if (map.containsKey(sum)) &#123;</span><br><span class="line">                 map.put(sum, map.get(sum) + 1);//纪录次数，也就是纪录的组合数字</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 map.put(sum, 1);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     int result = 0;</span><br><span class="line">     for (int c : nums3) &#123;</span><br><span class="line">         for (int d : nums4) &#123;</span><br><span class="line">             if (map.containsKey(0 - (c + d))) &#123;</span><br><span class="line">                 result = result + map.get(0 - (c + d));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>哈希表</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 530. 二叉搜索树的最小绝对差</title>
    <url>/2022/10/24/LeetCode530/</url>
    <content><![CDATA[<p>给你一个二叉搜索树的根节点 root ，返回 **树中任意两不同节点值之间的最小差值 **。   </p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<span id="more"></span>

<p>示例 1：<br><img src="/../images/leetcode530/bst1.jpg"></p>
<p>输入：root &#x3D; [4,2,6,1,3]<br>输出：1</p>
<p>示例 2：<br>输入：root &#x3D; [1,0,48,null,null,12,49]<br>输出：1</p>
<p>提示：</p>
<p>树中节点的数目范围是 [2, 104]<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 10^5</p>
<blockquote>
<p>中序遍历后的节点是有序的!!!<br>中序遍历后的节点是有序的!!!<br>中序遍历后的节点是有序的!!!</p>
<p>重要的事情说三遍、三遍、三遍</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">TreeNode pre = null;</span><br><span class="line">//最小值</span><br><span class="line">int min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这道题跟 98 差不多，都可以使用中序遍历（遍历后的节点是有序的）</span><br><span class="line"> * 在这个过程中，计算最小值，最后返回数值就可以了</span><br><span class="line"> */</span><br><span class="line">public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">    bfs(root);</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void bfs(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return;//遇到空节点跳过</span><br><span class="line">    &#125;</span><br><span class="line">    //左</span><br><span class="line">    bfs(root.left);</span><br><span class="line"></span><br><span class="line">    if (pre != null) &#123;</span><br><span class="line">        min = Math.min(min, root.val - pre.val);</span><br><span class="line">    &#125;</span><br><span class="line">    //注意不管当前有没有值，都需要左赋值操作</span><br><span class="line">    pre = root;</span><br><span class="line"></span><br><span class="line">    //右</span><br><span class="line">    bfs(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 538. 把二叉搜索树转换为累加树</title>
    <url>/2022/10/25/LeetCode538/</url>
    <content><![CDATA[<p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<span id="more"></span>

<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 小于 节点键的节点。  </li>
<li>节点的右子树仅包含键 大于 节点键的节点。  </li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<p>示例 1：<br><img src="/../images/leetcode538/tree.png">示例 1：</p>
<p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]  </p>
<p>示例 2：<br>输入：root &#x3D; [0,null,1]<br>输出：[1,null,1]  </p>
<p>示例 3：<br>输入：root &#x3D; [1,0,2]<br>输出：[3,3,2]  </p>
<p>示例 4：<br>输入：root &#x3D; [3,2,4,1]<br>输出：[7,9,4,10]  </p>
<p>提示：</p>
<ul>
<li>树中的节点数介于 0和 10^4之间。</li>
<li>每个节点的值介于 -10^4和10^4之间。</li>
<li>树中的所有值 互不相同 。</li>
<li>给定的树为二叉搜索树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 初始看这道题的描述，只想说Oh my god，说的是啥？</span><br><span class="line"> * 一翻评论区，发现很多人有相同的想法</span><br><span class="line"> * 其实这道题说的就是转变第一个节点是所有 当前节点+右侧节点之和</span><br><span class="line"> * 同理第二个节点新值为 当前节点+右侧节点之和</span><br><span class="line"> * 所以通过上述描述，自然也就简单了</span><br><span class="line"> * 在遍历节点我们有前、中、后序遍历，这里得要使用中序遍历，不过是反过来的中序，也就是 右中左的顺序</span><br><span class="line"> */</span><br><span class="line">public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;//递归的必要介绍条件</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    root.right = convertBST(root.right);//右</span><br><span class="line">    if (pre != null) &#123;</span><br><span class="line">        //上一个节点+本节点之和赋值给当前节点</span><br><span class="line">        root.val = pre.val + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    //当前节点赋给前置节点</span><br><span class="line">    pre = root;</span><br><span class="line">    root.left = convertBST(root.left);//左</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//前置节点</span><br><span class="line">private TreeNode pre = null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 54. 螺旋矩阵</title>
    <url>/2022/10/04/LeetCode54/</url>
    <content><![CDATA[<blockquote>
<p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
</blockquote>
<span id="more"></span> 



<blockquote>
<p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p>
<p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * m行n列，所以矩阵中一共的元素为 m*n</span><br><span class="line"> * 所以每输除一个元素，总值减-</span><br><span class="line"> */</span><br><span class="line">public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span><br><span class="line">    //行 * 列 得出最大个数</span><br><span class="line">    int mCount = matrix.length * matrix[0].length;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(mCount);</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    //行坐标的开始值为0</span><br><span class="line">    int startx = 0;</span><br><span class="line">    //纵坐标的开始值为0</span><br><span class="line">    int starty = 0;</span><br><span class="line">    int loop = 0;//从第一轮开始</span><br><span class="line">    //循环的次数必须要同时少于行中点以及纵中点</span><br><span class="line">    while (loop &lt; matrix.length / 2 &amp;&amp; loop &lt; matrix[0].length / 2) &#123;</span><br><span class="line">        i = starty;</span><br><span class="line">        j = startx;</span><br><span class="line">        loop++;</span><br><span class="line"></span><br><span class="line">        //从左上到右上</span><br><span class="line">        for (; j &lt; matrix[0].length - loop; j++) &#123;</span><br><span class="line">            list.add(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        //右上到右下</span><br><span class="line">        for (; i &lt; matrix.length - loop; i++) &#123;</span><br><span class="line">            list.add(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        //右下到左下</span><br><span class="line">        for (; j &gt; startx; j--) &#123;</span><br><span class="line">            list.add(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        //左下到左上</span><br><span class="line">        for (; i &gt; starty; i--) &#123;</span><br><span class="line">            list.add(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        starty++;</span><br><span class="line">        startx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (list.size() != mCount) &#123;</span><br><span class="line">        if (matrix[0].length / 2 &gt; loop &amp;&amp; matrix[0].length != 1) &#123;</span><br><span class="line">            //从左上到右上</span><br><span class="line">            while (matrix[0].length - loop - startx &gt; 0) &#123;</span><br><span class="line">                list.add(matrix[starty][startx++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (matrix.length - loop - starty &gt; 0) &#123;</span><br><span class="line">                list.add(matrix[starty++][startx]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 450. 删除二叉搜索树中的节点</title>
    <url>/2022/10/25/LeetCode450/</url>
    <content><![CDATA[<p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<span id="more"></span>

<p>一般来说，删除节点可分为两个步骤：</p>
<ul>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。</li>
</ul>
<p>示例 1:<br><img src="/../images/leetcode450/del_node_1.jpg"></p>
<p>输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。<br><img src="/../images/leetcode450/del_node_supp.jpg"></p>
<p>示例 2:</p>
<p>输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0<br>输出: [5,3,6,2,4,null,7]<br>解释: 二叉树不包含值为 0 的节点<br>示例 3:</p>
<p>输入: root &#x3D; [], key &#x3D; 0<br>输出: []</p>
<p>提示:</p>
<ul>
<li>节点数的范围[0, 10^4].</li>
<li>-10^5&lt;&#x3D; Node.val &lt;&#x3D; 10^5</li>
<li>节点值唯一</li>
<li>root是合法的二叉搜索树</li>
<li>-10^5&lt;&#x3D; key &lt;&#x3D; 10^5</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 删除节点会有5种情况需要考虑，我在会代码上注释</span><br><span class="line"> * 这个还是中序遍历</span><br><span class="line"> */</span><br><span class="line">public TreeNode deleteNode(TreeNode root, int key) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果找到节点</span><br><span class="line">    if (root.val == key) &#123;</span><br><span class="line">        if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">            //左右孩子都是空，返回null（表示当前节点已经删除）</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else if (root.right == null) &#123;</span><br><span class="line">            //右空，左不空 返回当前节点的左节点</span><br><span class="line">            return root.left;</span><br><span class="line">        &#125; else if (root.left == null) &#123;</span><br><span class="line">            //同理</span><br><span class="line">            return root.right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //左右孩子都不为空，那么就将左孩子挂到 右子树的最左叶子节点上</span><br><span class="line">            //那么就需要找到右子树的最左叶子</span><br><span class="line">            TreeNode cur = root.right;</span><br><span class="line">            while (cur.left != null) &#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.left = root.left;</span><br><span class="line">            root = root.right;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (key &lt; root.val) &#123;</span><br><span class="line">        //小于就左</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //大于就右</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 559. N 叉树的最大深度</title>
    <url>/2022/10/19/LeetCode559/</url>
    <content><![CDATA[<blockquote>
<p>给定一个 N 叉树，找到其最大深度。<br>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。  </p>
</blockquote>
<span id="more"></span>
<p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>
<p>示例 1：<br><img src="/../images/leetcode559/narytreeexample.png"></p>
<p>输入：root &#x3D; [1,null,3,2,4,null,5,6]<br>输出：3</p>
<p>示例 2：<br><img src="/../images/leetcode559/sample_4_964.png"></p>
<p>输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：5  </p>
<p>提示：<br>树的深度不会超过1000 。<br>树的节点数目位于 [0,10^4] 之间。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * DFS一般都是递归</span><br><span class="line"> * 确立入参出参，结束条件，函数编写</span><br><span class="line"> */</span><br><span class="line">public int dfs(Node root, int depth) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;//当前深度</span><br><span class="line">    int curDp = depth;</span><br><span class="line">    for (int i = 0; i &lt; root.children.size(); i++) &#123;</span><br><span class="line">        Node node = root.children.get(i);</span><br><span class="line">        int dfs = dfs(node, depth);//孩子节点的深度</span><br><span class="line">        curDp = Math.max(curDp, dfs);//将最大值赋给cutDp</span><br><span class="line">    &#125;</span><br><span class="line">    return curDp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int bfs(Node root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; qe = new LinkedList&lt;&gt;();</span><br><span class="line">    qe.offer(root);</span><br><span class="line">    int depth = 0;</span><br><span class="line">    while (!qe.isEmpty()) &#123;</span><br><span class="line">        int size = qe.size();</span><br><span class="line">        depth++;</span><br><span class="line">        while (size-- &gt; 0) &#123;</span><br><span class="line">            Node node = qe.poll();</span><br><span class="line">            //下面的操作是将子集入队列</span><br><span class="line">            if (node.children != null &amp;&amp; node.children.size() &gt; 0) &#123;</span><br><span class="line">                for (int i = 0; i &lt; node.children.size(); i++) &#123;</span><br><span class="line">                    if (node.children.get(i) != null) &#123;</span><br><span class="line">                        qe.offer(node.children.get(i));//加入队列</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 58 - II. 左旋转字符串</title>
    <url>/2022/10/12/LeetCode58/</url>
    <content><![CDATA[<blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。  </p>
</blockquote>
<span id="more"></span>

<p>示例 1：</p>
<p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出:”cdefgab”  </p>
<p>示例 2：  </p>
<p>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出:”umghlrlose”</p>
<p>限制：<br>1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一般看到翻转字符串，必须要想要双指针以及，通过两次翻转,局部翻转以及全局翻转从而达到目的</span><br><span class="line"> */</span><br><span class="line">public String reverseLeftWords(String s, int n) &#123;</span><br><span class="line">    char[] chars = s.toCharArray();</span><br><span class="line">    reserse(chars, 0, n - 1);</span><br><span class="line">    reserse(chars, n, chars.length - 1);</span><br><span class="line">    reserse(chars, 0, chars.length - 1);</span><br><span class="line">    return new String(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param c 字符数组</span><br><span class="line"> * @param l 左指针</span><br><span class="line"> * @param r 右指针</span><br><span class="line"> */</span><br><span class="line">public static void reserse(char[] c, int l, int r) &#123;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        char temp = c[l];</span><br><span class="line">        c[l] = c[r];</span><br><span class="line">        c[r] = temp;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>翻转</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 541. 反转字符串 II</title>
    <url>/2022/10/12/LeetCode541/</url>
    <content><![CDATA[<blockquote>
<p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。  </p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。  </p>
</blockquote>
<p>示例 1：</p>
<p>输入：s &#x3D; “abcdefg”, k &#x3D; 2<br>输出：”bacdfeg”<br>示例 2：  </p>
<p>输入：s &#x3D; “abcd”, k &#x3D; 2<br>输出：”bacd”  </p>
<p>提示：  </p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s 仅由小写英文组成<br>1 &lt;&#x3D; k &lt;&#x3D; 104  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这道题主要是找到需要翻转字符的下标</span><br><span class="line"> * i 每次递增都是 2k</span><br><span class="line"> */</span><br><span class="line">public String reverseStr(String s, int k) &#123;</span><br><span class="line">    char[] chars = s.toCharArray();</span><br><span class="line">    //i的起点每次递增2k</span><br><span class="line">    for (int i = 0; i &lt; chars.length; i = i + 2 * k) &#123;</span><br><span class="line">        if (i + k &gt; chars.length - 1) &#123;</span><br><span class="line">            reverseChar(chars, i, chars.length - 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            reverseChar(chars, i, i + k - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void reverseChar(char[] chars, int l, int r) &#123;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        char temp = chars[l];</span><br><span class="line">        chars[l] = chars[r];</span><br><span class="line">        chars[r] = temp;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 654. 最大二叉树</title>
    <url>/2022/10/22/LeetCode654/</url>
    <content><![CDATA[<p>给定一个不重复的整数数组nums 。最大二叉树可以用下面的算法从nums 递归地构建:</p>
<ul>
<li>创建一个根节点，其值为nums 中的最大值。</li>
<li>递归地在最大值左边的子数组前缀上构建左子树。</li>
<li>递归地在最大值 右边 的子数组后缀上构建右子树。</li>
</ul>
<p>返回nums 构建的 最大二叉树 。</p>
<span id="more"></span>

<p>示例 1：<br><img src="/../images/leetcode654/tree1.jpg"></p>
<p>输入：nums &#x3D; [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p>
<ul>
<li>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。<ul>
<li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。<ul>
<li>空数组，无子节点。</li>
<li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul>
<li>空数组，无子节点。</li>
<li>只有一个元素，所以子节点是一个值为 1 的节点。</li>
</ul>
</li>
</ul>
</li>
<li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul>
<li>只有一个元素，所以子节点是一个值为 0 的节点。</li>
<li>空数组，无子节点。<br>示例 2：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>输入：nums &#x3D; [3,2,1]<br>输出：[3,null,2,null,1]</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000</li>
<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>
<li>nums 中的所有整数 互不相同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据题意，就是使用中序遍历，先确立当前节点，然后在确立左子树，右子树</span><br><span class="line"> */</span><br><span class="line">public TreeNode constructMaximumBinaryTree(int[] nums) &#123;</span><br><span class="line">    //数组是空，那么就返回null节点</span><br><span class="line">    if (nums == null || nums.length == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //确立当前节点，就需要查询当前数组中的最大值，这里是O（N）</span><br><span class="line">    int size = nums.length - 1;</span><br><span class="line">    int maxNum = -1;//根据题意，数组数值大于等于0</span><br><span class="line">    int maxIndex = -1;</span><br><span class="line">    while (size &gt;= 0) &#123;</span><br><span class="line">        if (nums[size] &gt; maxNum) &#123;</span><br><span class="line">            maxNum = nums[size];</span><br><span class="line">            maxIndex = size;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode curNode = new TreeNode(maxNum);</span><br><span class="line">    //构造左子树</span><br><span class="line">    curNode.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, 0, maxIndex));</span><br><span class="line">    //构造右子树</span><br><span class="line">    curNode.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + 1, nums.length));</span><br><span class="line">    //返回当前节点</span><br><span class="line">    return curNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 669. 修剪二叉搜索树</title>
    <url>/2022/10/25/LeetCode669/</url>
    <content><![CDATA[<p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。</p>
<span id="more"></span>
<p>通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一</strong> 的答案。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
<p>示例 1：<br><img src="/../images/leetcode669/trim1.jpg"></p>
<p>输入：root &#x3D; [1,0,2], low &#x3D; 1, high &#x3D; 2<br>输出：[1,null,2]  </p>
<p>示例 2：<br><img src="/../images/leetcode669/trim2.jpg"></p>
<p>输入：root &#x3D; [3,0,4,null,2,null,null,1], low &#x3D; 1, high &#x3D; 3<br>输出：[3,2,null,1]  </p>
<p>提示：</p>
<ul>
<li>树中节点数在范围 [1, 10^4] 内</li>
<li>0 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</li>
<li>树中每个节点的值都是 唯一 的</li>
<li>题目数据保证输入是一棵有效的二叉搜索树</li>
<li>0 &lt;&#x3D; low &lt;&#x3D; high &lt;&#x3D; 10^4</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用的是中序遍历</span><br><span class="line"> */</span><br><span class="line">public TreeNode trimBST(TreeNode root, int low, int high) &#123;</span><br><span class="line">    //如果达到了底层，那么就返回空</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //节点不为空</span><br><span class="line">    if (root.val &lt; low) &#123;</span><br><span class="line">        //如果当前节点的值比最小范围还要小，那么就删除当前节点以及左孩子树,但是需要返回 已经遍历过的右子树</span><br><span class="line">        //因为右子树可能也有不在这个范围的节点</span><br><span class="line">        return trimBST(root.right, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.val &gt; high) &#123;</span><br><span class="line">        return trimBST(root.left, low, high);//与上同理</span><br><span class="line">    &#125;</span><br><span class="line">    //接着就递归左孩子以及右孩子</span><br><span class="line">    root.left = trimBST(root.left, low, high);</span><br><span class="line">    root.right = trimBST(root.right, low, high);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 701. 二叉搜索树中的插入操作</title>
    <url>/2022/10/24/LeetCode701/</url>
    <content><![CDATA[<p>给定二叉搜索树（BST）的根节点root和要插入树中的值value，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。  </p>
<span id="more"></span>

<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。  </p>
<p>示例 1：<br>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5<br>输出：[4,2,7,1,3,5]<br>解释：另一个满足题目要求可以通过的树是：  </p>
<p>示例 2：<br>输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25<br>输出：[40,20,60,10,30,50,70,null,null,25]  </p>
<p>示例 3：</p>
<p>输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5<br>输出：[4,2,7,1,3,5]  </p>
<p>提示：<br>树中的节点数将在[0,10^4]的范围内。<br>-10^8&lt;&#x3D; Node.val &lt;&#x3D; 10^8<br>所有值Node.val是独一无二的。<br>-10^8&lt;&#x3D; val &lt;&#x3D; 10^8<br>保证val在原始BST中不存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 二叉树，只需要确保 当前节点大于左子树节点，同时小于右子树的节点即可，不需要管平衡树</span><br><span class="line"> * 以下是前序遍历</span><br><span class="line"> */</span><br><span class="line">public TreeNode insertIntoBST(TreeNode root, int val) &#123;</span><br><span class="line">    //当前节点是空，就直接插入</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return new TreeNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    if (val &lt; root.val) &#123;</span><br><span class="line">        root.left = insertIntoBST(root.left, val);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        root.right = insertIntoBST(root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 69. x 的平方根</title>
    <url>/2022/10/04/LeetCode69/</url>
    <content><![CDATA[<blockquote>
<p>给你一个非负整数 x ，计算并返回x的 算术平方根 。<br>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。<br>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。  </p>
</blockquote>
<span id="more"></span> 

<blockquote>
<p>输入：x &#x3D; 4<br>输出：2</p>
<p>输入：x &#x3D; 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 暴力算法一般容易超出时间限制</span><br><span class="line"> */</span><br><span class="line">public static int baoLi(int x) &#123;</span><br><span class="line">    for (int i = 0; i &lt;= x; i++) &#123;</span><br><span class="line">        int a = i * i;</span><br><span class="line">        if (a == x) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a &gt; x) &#123;</span><br><span class="line">            return i - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 二分法 0 ~ x 之间切割</span><br><span class="line"> */</span><br><span class="line">public static int twoSplit(int x) &#123;</span><br><span class="line">    int l = 0;</span><br><span class="line">    int r = x;</span><br><span class="line">    int ans = -1;</span><br><span class="line">    while (l &lt;= r) &#123;</span><br><span class="line">        int mid = l + (r - l) / 2;</span><br><span class="line">        //这里需要转换long，防止溢出</span><br><span class="line">        if ((long) mid * mid &lt;= x) &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">            //ans必须要在l这边，因为题意是要的商</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 700. 二叉搜索树中的搜索</title>
    <url>/2022/10/23/LeetCode700/</url>
    <content><![CDATA[<p>给定二叉搜索树（BST）的根节点root和一个整数值val。<br>你需要在 BST 中找到节点值等于val的节点。 返回以该节点为根的子树。 如果节点不存在，则返回null。  </p>
<span id="more"></span>


<p>示例 1:<br><img src="/../images/leetcode700/tree1.jpg"></p>
<p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2<br>输出：[2,1,3]  </p>
<p>示例 2:<br><img src="/../images/leetcode700/tree2.jpg"></p>
<p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5<br>输出：[]  </p>
<p>提示：</p>
<p>数中节点数在[1, 5000]范围内<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 10^7<br>root是二叉搜索树<br>1 &lt;&#x3D; val &lt;&#x3D; 10^7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 二叉搜索树，因为是有序的，左节点&lt;中节点&lt;右节点，所以感觉操作起来比一般的二叉树还要简单</span><br><span class="line"> */</span><br><span class="line">public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">    LeetCode700 code700 = new LeetCode700();</span><br><span class="line">    TreeNode dfs = code700.dfs(root, val);</span><br><span class="line">    TreeNode bfs = code700.bfs(root, val);</span><br><span class="line">    return dfs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用递归</span><br><span class="line"> */</span><br><span class="line">public TreeNode dfs(TreeNode root, int val) &#123;</span><br><span class="line">    //如果为空或者找到相同值，返回当前节点</span><br><span class="line">    if (root == null || root.val == val) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode node = null;</span><br><span class="line">    if (root.val &lt; val) &#123;//值大于中节点，往右走</span><br><span class="line">        node = dfs(root.right, val);</span><br><span class="line">    &#125; else if (root.val &gt; val) &#123;</span><br><span class="line">        node = dfs(root.left, val);//往左走</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 层序遍历</span><br><span class="line"> */</span><br><span class="line">public TreeNode bfs(TreeNode root, int val) &#123;</span><br><span class="line">    while (root != null) &#123;</span><br><span class="line">        if (root.val &lt; val) &#123;//值大于中节点，往右走</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; else if (root.val &gt; val) &#123;</span><br><span class="line">            root = root.left;//往左走</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 904. 水果成篮</title>
    <url>/2022/10/06/LeetCode904/</url>
    <content><![CDATA[<blockquote>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。<br>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<ul>
<li>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</li>
<li>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>
<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>
</ul>
<p>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>输入：fruits &#x3D; [1,2,1]<br>输出：3<br>解释：可以采摘全部 3 棵树。  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据题意，意思是从数组的随意一个下标开始往右走，遇到的数值类型只能是两种，那么从哪下标开始走，走过的路程最远</span><br><span class="line"> * 这道题就是典型的滑动窗口+权重比例</span><br><span class="line"> * 需要额外的添加权重哈希参数</span><br><span class="line"> */</span><br><span class="line">public int totalFruit(int[] fruits) &#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int i = 0;//初始化左指针，就是滑动窗口的左指针</span><br><span class="line">    Counter counter = new Counter();</span><br><span class="line">    //使用哈希篮子</span><br><span class="line">    //外循环从头遍历到尾</span><br><span class="line">    for (int j = 0; j &lt; fruits.length; j++) &#123;</span><br><span class="line">        counter.add(fruits[j]);</span><br><span class="line">        while (counter.size() &gt; 2) &#123;</span><br><span class="line">            //如果篮子种类多余两种，需要去除前面添加的那些,这里的i会缩小，不断将之前添加的数值移除</span><br><span class="line">            //当移除到一定程度，篮子剩下就只有最多两种水果，这是这道题最关键的地方</span><br><span class="line">            counter.remote(fruits[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(j - i + 1, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Counter extends HashMap&lt;Integer, Integer&gt; &#123;</span><br><span class="line">    public int get(int k) &#123;</span><br><span class="line">        return containsKey(k) ? super.get(k) : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(int k) &#123;</span><br><span class="line">        int i = get(k);</span><br><span class="line">        if (i == 0) &#123;</span><br><span class="line">            super.put(k, 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.put(k, i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remote(int k) &#123;</span><br><span class="line">        int i = get(k);</span><br><span class="line">        if (i == 1) &#123;</span><br><span class="line">            //如果值等于0，移除</span><br><span class="line">            super.remove(k);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.put(k, i - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 77. 组合</title>
    <url>/2022/10/28/LeetCode77/</url>
    <content><![CDATA[<p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>你可以按 任何顺序 返回答案。  </p>
<span id="more"></span>

<p>示例 1：<br>输入：n &#x3D; 4, k &#x3D; 2<br>输出：<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]  </p>
<p>示例 2：<br>输入：n &#x3D; 1, k &#x3D; 1<br>输出：[[1]]  </p>
<p>提示： </p>
<ul>
<li>1 &lt;&#x3D; n &lt;&#x3D; 20  </li>
<li>1 &lt;&#x3D; k &lt;&#x3D; n</li>
</ul>
<p>Ps：这是一道经典的组合回溯题，需要经常回顾细品。<br><img src="/../images/leetcode77/20201123195242899.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这道题需要的是组合，组合是不需要考虑顺序，所以每个都参与组合操作</span><br><span class="line"> * 一般组合，排序都是使用回溯法，回溯法其实就是暴力破解的升级版，是一款穷举的破解法</span><br><span class="line"> * 回溯法的好处是，使用递归的编程方式，隐盖了原本需要多个for循环的操作</span><br><span class="line"> */</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">    tracking(n, k, 0);</span><br><span class="line">    return rel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void tracking(int n, int k, int stId) &#123;</span><br><span class="line">    //如果item的数量等于 k，那么就把数据copy一份到结果集</span><br><span class="line">    if (item.size() == k) &#123;</span><br><span class="line">        rel.add(new ArrayList&lt;&gt;(item));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = stId; i &lt;= n - (k - item.size()) + 1; i++) &#123;//这里需要做一个剪枝的操作,简单的理解,i的最大值为：n-k+1(+1是因为两个数值相减后需要加一才是距离)，细品~</span><br><span class="line">        //每次操作一个元素，入栈</span><br><span class="line">        item.add(i);</span><br><span class="line">        tracking(n, k, i + 1);//当前节点i已经使用过了，所以需要在当前节点+1;切记这里使用的是i，而不是stId</span><br><span class="line">        //出栈</span><br><span class="line">        item.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 结果集合</span><br><span class="line"> */</span><br><span class="line">private List&lt;List&lt;Integer&gt;&gt; rel = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 每次的结果集</span><br><span class="line"> */</span><br><span class="line">private LinkedList&lt;Integer&gt; item = new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 977. 有序数组的平方</title>
    <url>/2022/10/06/LeetCode977/</url>
    <content><![CDATA[<blockquote>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>输入：nums &#x3D; [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * nums = [-4,-1,0,3,10]</span><br><span class="line"> * 如果使用暴力解法，先一轮循环将所有的数值乘方后再快速排序，时间复杂度应该是 O（nlogn）</span><br><span class="line"> * 根据题意分析，实际上可能数组有负数，所以，有可能乘方之后，最小的值在数组中间</span><br><span class="line"> * 所有需要考虑使用双指针法，左右指针相遇，程序结束</span><br><span class="line"> */</span><br><span class="line">public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">    int l = 0;</span><br><span class="line">    int r = nums.length - 1;</span><br><span class="line">    int[] ret = new int[nums.length];</span><br><span class="line">    int k = nums.length - 1;</span><br><span class="line">    while (l &lt;= r) &#123;</span><br><span class="line">        if ((long) nums[l] * nums[l] &lt;= (long) nums[r] * nums[r]) &#123;</span><br><span class="line">            ret[k--] = nums[r] * nums[r];</span><br><span class="line">            --r;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ret[k--] = nums[l] * nums[l];</span><br><span class="line">            ++l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 98. 验证二叉搜索树</title>
    <url>/2022/10/24/LeetCode98/</url>
    <content><![CDATA[<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 小于 当前节点的数。  </li>
<li>节点的右子树只包含 大于 当前节点的数。  </li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<span id="more"></span>
<p>示例 1：<br>输入：root &#x3D; [2,1,3]<br>输出：true</p>
<p>示例 2：<br>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。  </p>
<p>提示：<br>树中节点数目范围在[1, 10^4] 内<br>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p>
<blockquote>
<p>由于中序遍历的的节点，刚好是符合二叉搜索树的规范，是一到从小到大的顺序节点<br>因为题目的值范围超过 Integer.MIN_VALUE 所以需要有一个TreeNode节点的值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 98. 验证二叉搜索树</span><br><span class="line"> */</span><br><span class="line">public class LeetCode98 &#123;</span><br><span class="line"></span><br><span class="line">    private TreeNode node = null;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 可是使用中序遍历，先验证左节点，在验证中间节点，再验证右节点</span><br><span class="line">     * 因为中序遍历的节点，是一个顺序递增的数组</span><br><span class="line">     */</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;//如果节点空，那么默认true</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //左</span><br><span class="line">        boolean left = isValidBST(root.left);</span><br><span class="line">        if (!left) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //中</span><br><span class="line">        if (node != null &amp;&amp; root.val &lt;= node.val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        node = root;</span><br><span class="line">        //右</span><br><span class="line">        boolean right = isValidBST(root.right);</span><br><span class="line">        if (!right) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>经典算法之-回溯法</title>
    <url>/2022/10/28/huiSuFa/</url>
    <content><![CDATA[<h1 id="1、什么是回溯法"><a href="#1、什么是回溯法" class="headerlink" title="1、什么是回溯法"></a>1、什么是回溯法</h1><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。 但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<span id="more"></span>

<h1 id="2、回溯法的效率"><a href="#2、回溯法的效率" class="headerlink" title="2、回溯法的效率"></a>2、回溯法的效率</h1><p>回溯法的效率，说到效率，其实回溯法并不是什么高效的算法，也不能称之为一种算法，更像是一种模板，一种固定形式的写法；</p>
<p>因为回溯的本质就是穷举，穷举所有的可能，然后在穷举的过程中，提取我们需要的结果。</p>
<p>那么既然回溯法并不高效为什么还要用它呢？</p>
<p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p>
<p>此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。</p>
<h1 id="3、回溯法能解决的问题"><a href="#3、回溯法能解决的问题" class="headerlink" title="3、回溯法能解决的问题"></a>3、回溯法能解决的问题</h1><a href="/2022/10/28/LeetCode17/" title="LeetCode 17. 电话号码的字母组合">LeetCode 17. 电话号码的字母组合</a>  
<br>
<a href="/2022/10/28/LeetCode77/" title="LeetCode 77. 组合">LeetCode 77. 组合</a>
<br>
<a href="/2022/10/28/LeetCode216/" title="LeetCode 216. 组合总和 III">LeetCode 216. 组合总和 III</a>
<br>

<p>组合是不强调元素顺序的，排列是强调元素顺序。</p>
<h1 id="4、掌握回溯法"><a href="#4、掌握回溯法" class="headerlink" title="4、掌握回溯法"></a>4、掌握回溯法</h1><p>人的脑回路不是无穷的，一般人只需要能递归两到三层就够了，再多会导致思维混乱，所以想要“形象”的掌握回溯，那就把它想象成“一棵树”。</p>
<p>回溯算法模板框架如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 35. 搜索插入位置</title>
    <url>/2022/09/28/leetcode35/</url>
    <content><![CDATA[<blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>示例 1:<br>输入: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>输出: 2  </p>
<p>示例 2:<br>输入: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>输出: 1  </p>
<p>示例 3:<br>输入: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>输出: 4  </p>
<p>提示:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 为无重复元素的升序排列数组<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr>
<p>根据题意，这是一个有序的数组，所以一般对于查找数据，需要立马条件反射到使用二分查找，因为二分查找的时间复杂度为：<strong>O(logN)</strong> ,满足题意</p>
<p>对于一个数插入原数组，需要满足以下条件</p>
<ul>
<li>目标值在数组所有元素之前</li>
<li>目标值等于数组中某一个元素</li>
<li>目标值插入数组中的位置</li>
<li>目标值在数组所有元素之后</li>
</ul>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 由于题目要求 O(log n),所以要考虑到 二分法，递归等</span><br><span class="line"> *</span><br><span class="line"> * @param nums 数组</span><br><span class="line"> * @param target 目标值</span><br><span class="line"> * @return 下标</span><br><span class="line"> */</span><br><span class="line">public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">    if (nums == null || nums.length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int l = 0;</span><br><span class="line">    int r = nums.length - 1;</span><br><span class="line">    //在 l跟r的闭区间内</span><br><span class="line">    while (l &lt;= r) &#123;</span><br><span class="line">        int mid = l + (r - l) / 2;</span><br><span class="line">        if (nums[mid] &gt; target) &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果target小于数组的第一个值，那么插入后的位置就是0</span><br><span class="line">            //基于上述的原因，这里的mid会等于l，也就是等于0</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>树的迭代遍历</title>
    <url>/2022/10/17/%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<blockquote>
<p>树的深度遍历有中序遍历，前序遍历，后续遍历，在用递归的方式实现，过于简单，那么假如使用迭代的方式，也一样简单吗？</p>
</blockquote>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 前序遍历</span><br><span class="line"> * 中、左、右</span><br><span class="line"> * 由于遍历顺序与元素的操作顺序一致，所以可以简单的使用栈来实现</span><br><span class="line"> */</span><br><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    //栈不为空</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode pop = stack.pop();</span><br><span class="line">        if (pop != null) &#123;</span><br><span class="line">            result.add(pop.val);</span><br><span class="line">            stack.push(pop.rigth);</span><br><span class="line">            stack.push(pop.left);//栈的结构，后入先出</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 后续遍历</span><br><span class="line"> * 左、右、中</span><br><span class="line"> * 后续遍历就是 前序遍历的，左右对调，然后结果集翻转</span><br><span class="line"> */</span><br><span class="line">public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    //栈不为空</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode pop = stack.pop();</span><br><span class="line">        if (pop != null) &#123;</span><br><span class="line">            result.add(pop.val);</span><br><span class="line">            stack.push(pop.rigth);</span><br><span class="line">            stack.push(pop.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //此时数组中的元素 应该是 中，右、 左</span><br><span class="line">    reverse(result);</span><br><span class="line">    //翻转之后，结果应该是 左、右、中</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void reverse(List&lt;Integer&gt; result) &#123;</span><br><span class="line">    int l = 0;</span><br><span class="line">    int r = result.size() - 1;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        int temp = result.get(l);</span><br><span class="line">        result.set(l, result.get(r));</span><br><span class="line">        result.set(r, temp);</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 中序遍历</span><br><span class="line"> * 左、中、右</span><br><span class="line"> * 中序遍历跟前后序遍历都不一样，主要是因为遍历的时候顺序跟元素操作的顺序不一致导致的</span><br><span class="line"> * 可以思考如下图的中序遍历</span><br><span class="line"> *      5</span><br><span class="line"> *     /  \</span><br><span class="line"> *   4     6</span><br><span class="line"> *  /  \</span><br><span class="line"> * 1    2</span><br><span class="line"> */</span><br><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    while (cur != null || !st.isEmpty()) &#123;</span><br><span class="line">        //当前元素不为空，继续插入左侧元素</span><br><span class="line">        if (cur != null) &#123;</span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果为空，输出栈里面的元素</span><br><span class="line">            TreeNode pop = st.pop();</span><br><span class="line">            result.add(pop.val);//当前元素是栈顶元素的左子树</span><br><span class="line">            cur = cur.rigth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 19. 删除链表的倒数第 N 个结点</title>
    <url>/2022/10/03/leetcode19/</url>
    <content><![CDATA[<blockquote>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]</p>
<p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 头结点使用虚拟节点处理</span><br><span class="line"> * 使用快慢指针</span><br><span class="line"> * 快指针先走N部</span><br><span class="line"> * 接着快慢指针一起走</span><br><span class="line"> * x = N + M ;</span><br><span class="line"> * 最终慢指针的下一个节点就是需要删除的节点（慢指针走了 M 步）</span><br><span class="line"> */</span><br><span class="line">public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">    ListNode dummp = new ListNode(0, head);</span><br><span class="line">    ListNode fastNode = dummp;</span><br><span class="line">    ListNode showNode = dummp;</span><br><span class="line">    while (fastNode.next != null) &#123;</span><br><span class="line">        fastNode = fastNode.next;</span><br><span class="line">        if (n-- &lt;= 0) &#123;</span><br><span class="line">            //快指针已经走了N步，此时慢指针开始走</span><br><span class="line">            showNode = showNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (showNode.next != null) &#123;</span><br><span class="line">        showNode.next = showNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummp.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>树的迭代遍历统一写法</title>
    <url>/2022/10/17/%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>刚学完树的迭代遍历，但是不一样的写法，会导致人大佬迷糊记不清，所以在此纪录一下统一的写法</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>里面的方法使用到的是空标记法，单判断到空字节，则证明需要处理空节点了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 前序遍历</span><br><span class="line"> * 中、左、右</span><br><span class="line"> */</span><br><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    //栈不为空</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.peek();</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            stack.push(node.rigth);//右</span><br><span class="line">            stack.push(node.left);//左</span><br><span class="line">            stack.push(node);     //中</span><br><span class="line">            stack.push(null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stack.pop();//弹出空元素</span><br><span class="line">            node = stack.peek();</span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">                result.add(node.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 后续遍历</span><br><span class="line"> * 左、右、中</span><br><span class="line"> */</span><br><span class="line">public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    //栈不为空</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.peek();</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            stack.push(node);     //中</span><br><span class="line">            stack.push(null);</span><br><span class="line">            stack.push(node.rigth);//右</span><br><span class="line">            stack.push(node.left);//左</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stack.pop();//弹出空元素</span><br><span class="line">            node = stack.peek();</span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">                result.add(node.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 中序遍历</span><br><span class="line"> * 左、中、右</span><br><span class="line"> */</span><br><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    //栈不为空</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.peek();</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            stack.push(node.rigth);//右</span><br><span class="line">            stack.push(node);     //中</span><br><span class="line">            stack.push(null);</span><br><span class="line">            stack.push(node.left);//左</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stack.pop();//弹出空元素</span><br><span class="line">            node = stack.peek();</span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">                result.add(node.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/06/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>排序算法是每个开发都必须要熟练掌握，是研究算法题的开端</p>
</blockquote>
<p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p>
<p>排序算法总览：<br><img src="/../images/0006/a.png" alt="总括"></p>
<span id="more"></span>

<h1 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h1><p>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。<br>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；<br>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序<br>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</p>
<h1 id="关于稳定性"><a href="#关于稳定性" class="headerlink" title="关于稳定性"></a>关于稳定性</h1><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。<br>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>
<p>名词解释：</p>
<ul>
<li>n：数据规模</li>
<li>k：”桶”的个数</li>
<li>In-place：占用常数内存，不占用额外内存</li>
<li>Out-place：占用额外内存</li>
<li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li>
</ul>
<hr>
<h1 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h1><h2 id="1-1-算法步骤"><a href="#1-1-算法步骤" class="headerlink" title="1.1 算法步骤"></a>1.1 算法步骤</h2><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<h2 id="1-2-动图演示"><a href="#1-2-动图演示" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h2><p><img src="/../images/0006/b.gif" alt="冒泡"></p>
<h2 id="2-3-什么时候最快"><a href="#2-3-什么时候最快" class="headerlink" title="2.3 什么时候最快"></a>2.3 什么时候最快</h2><p>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</p>
<h2 id="2-4-什么时候最慢"><a href="#2-4-什么时候最慢" class="headerlink" title="2.4 什么时候最慢"></a>2.4 什么时候最慢</h2><p>当输入的数据是反序时</p>
<h2 id="2-5-实现"><a href="#2-5-实现" class="headerlink" title="2.5 实现"></a>2.5 实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BubbleSort implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line">        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span><br><span class="line">            // 这里是冒泡排序的优化项</span><br><span class="line">            boolean flag = true;</span><br><span class="line"></span><br><span class="line">            for (int j = 0; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    int tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + 1];</span><br><span class="line">                    arr[j + 1] = tmp;</span><br><span class="line"></span><br><span class="line">                    flag = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h1><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h2 id="2-1-算法步骤"><a href="#2-1-算法步骤" class="headerlink" title="2.1 算法步骤"></a>2.1 算法步骤</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。</p>
<h2 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a>2.2 动图演示</h2><p><img src="/../images/0006/c.gif" alt="选择"></p>
<h2 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SelectionSort implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        // 总共要经过 N-1 轮比较</span><br><span class="line">        for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int min = i;</span><br><span class="line"></span><br><span class="line">            // 每轮需要比较的次数 N-i</span><br><span class="line">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                    // 记录目前能找到的最小值元素的下标</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 将找到的最小值和i位置所在的值进行交换</span><br><span class="line">            if (i != min) &#123;</span><br><span class="line">                int tmp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3、-插入排序"><a href="#3、-插入排序" class="headerlink" title="3、 插入排序"></a>3、 插入排序</h1><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<h2 id="3-1-算法步骤"><a href="#3-1-算法步骤" class="headerlink" title="3.1 算法步骤"></a>3.1 算法步骤</h2><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<h2 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h2><p><img src="/../images/0006/d.gif" alt="插入"></p>
<h2 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a>3.3 实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class InsertSort implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line">        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span><br><span class="line">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            // 记录要插入的数据</span><br><span class="line">            int tmp = arr[i];</span><br><span class="line"></span><br><span class="line">            // 从已经排序的序列最右边的开始比较，找到比其小的数</span><br><span class="line">            int j = i;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123;</span><br><span class="line">                arr[j] = arr[j - 1];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 存在比其小的数，插入</span><br><span class="line">            if (j != i) &#123;</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h1><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h2 id="4-1-算法步骤"><a href="#4-1-算法步骤" class="headerlink" title="4.1 算法步骤"></a>4.1 算法步骤</h2><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1；<br>按增量序列个数 k，对序列进行 k 趟排序；<br>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h2 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h2><p><img src="/../images/0006/e.gif" alt="希尔"></p>
<h2 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3 实现"></a>4.3 实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void shellSort(int[] arr) &#123;</span><br><span class="line">    int length = arr.length;</span><br><span class="line">    int temp;</span><br><span class="line">    for (int step = length / 2; step &gt;= 1; step /= 2) &#123;</span><br><span class="line">        for (int i = step; i &lt; length; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            int j = i - step;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + step] = arr[j];</span><br><span class="line">                j -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + step] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5、归并排序"><a href="#5、归并排序" class="headerlink" title="5、归并排序"></a>5、归并排序</h1><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：</p>
<blockquote>
<p>However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.<br>然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。</p>
</blockquote>
<p>说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。<br>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<h2 id="5-1-算法步骤"><a href="#5-1-算法步骤" class="headerlink" title="5.1 算法步骤"></a>5.1 算法步骤</h2><ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul>
<h2 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h2><p><img src="/../images/0006/f.gif" alt="归并"></p>
<h2 id="5-3-实现"><a href="#5-3-实现" class="headerlink" title="5.3 实现"></a>5.3 实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MergeSort implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line">        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        if (arr.length &lt; 2) &#123;</span><br><span class="line">            return arr;</span><br><span class="line">        &#125;</span><br><span class="line">        int middle = (int) Math.floor(arr.length / 2);</span><br><span class="line"></span><br><span class="line">        int[] left = Arrays.copyOfRange(arr, 0, middle);</span><br><span class="line">        int[] right = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line"></span><br><span class="line">        return merge(sort(left), sort(right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected int[] merge(int[] left, int[] right) &#123;</span><br><span class="line">        int[] result = new int[left.length + right.length];</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123;</span><br><span class="line">            if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">                result[i++] = left[0];</span><br><span class="line">                left = Arrays.copyOfRange(left, 1, left.length);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result[i++] = right[0];</span><br><span class="line">                right = Arrays.copyOfRange(right, 1, right.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (left.length &gt; 0) &#123;</span><br><span class="line">            result[i++] = left[0];</span><br><span class="line">            left = Arrays.copyOfRange(left, 1, left.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (right.length &gt; 0) &#123;</span><br><span class="line">            result[i++] = right[0];</span><br><span class="line">            right = Arrays.copyOfRange(right, 1, right.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6、快速排序"><a href="#6、快速排序" class="headerlink" title="6、快速排序"></a>6、快速排序</h1><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn)<br>算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为<br>O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p>
<blockquote>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<h2 id="6-1-算法步骤"><a href="#6-1-算法步骤" class="headerlink" title="6.1 算法步骤"></a>6.1 算法步骤</h2><ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;   </li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；  </li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ul>
<h2 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h2><p><img src="/../images/0006/g.gif" alt="动图"></p>
<h2 id="6-3-实现"><a href="#6-3-实现" class="headerlink" title="6.3 实现"></a>6.3 实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class QuickSort implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line">        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line">        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        return quickSort(arr, 0, arr.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int[] quickSort(int[] arr, int left, int right) &#123;</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            int partitionIndex = partition(arr, left, right);</span><br><span class="line">            quickSort(arr, left, partitionIndex - 1);</span><br><span class="line">            quickSort(arr, partitionIndex + 1, right);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int partition(int[] arr, int left, int right) &#123;</span><br><span class="line">        // 设定基准值（pivot）</span><br><span class="line">        int pivot = left;</span><br><span class="line">        int index = pivot + 1;</span><br><span class="line">        for (int i = index; i &lt;= right; i++) &#123;</span><br><span class="line">            if (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">                swap(arr, i, index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, index - 1);</span><br><span class="line">        return index - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
</search>
